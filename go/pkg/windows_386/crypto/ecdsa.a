!<arch>
__.PKGDEF       0           0     0     644     18878     `
go object windows 386 devel +ddfee9dfca20 Wed Apr 02 21:05:41 2014 -0700 X:precisestack

$$
package ecdsa
	import runtime "runtime"
	import io "io"
	import elliptic "crypto/elliptic"
	import big "math/big"
	type @"math/big".Word uintptr
	type @"math/big".divisor struct { @"math/big".bbb @"math/big".nat; @"math/big".nbits int; @"math/big".ndigits int }
	import rand "math/rand" // indirect
	type @"math/rand".Source interface { Int63() (? int64); Seed(@"math/rand".seed int64) }
	type @"math/rand".Rand struct { @"math/rand".src @"math/rand".Source }
	func (@"math/rand".rÂ·2 *@"math/rand".Rand) ExpFloat64 () (? float64)
	func (@"math/rand".rÂ·2 *@"math/rand".Rand) Float32 () (? float32)
	func (@"math/rand".rÂ·2 *@"math/rand".Rand) Float64 () (? float64)
	func (@"math/rand".rÂ·2 *@"math/rand".Rand) Int () (? int)
	func (@"math/rand".rÂ·2 *@"math/rand".Rand) Int31 () (? int32)
	func (@"math/rand".rÂ·2 *@"math/rand".Rand) Int31n (@"math/rand".nÂ·3 int32) (? int32)
	func (@"math/rand".rÂ·2 *@"math/rand".Rand) Int63 () (? int64)
	func (@"math/rand".rÂ·2 *@"math/rand".Rand) Int63n (@"math/rand".nÂ·3 int64) (? int64)
	func (@"math/rand".rÂ·2 *@"math/rand".Rand) Intn (@"math/rand".nÂ·3 int) (? int)
	func (@"math/rand".rÂ·2 *@"math/rand".Rand) NormFloat64 () (? float64)
	func (@"math/rand".rÂ·2 *@"math/rand".Rand) Perm (@"math/rand".nÂ·3 int) (? []int)
	func (@"math/rand".rÂ·1 *@"math/rand".Rand) Seed (@"math/rand".seedÂ·2 int64)
	func (@"math/rand".rÂ·2 *@"math/rand".Rand) Uint32 () (? uint32)
	type @"io".RuneScanner interface { ReadRune() (@"io".r rune, @"io".size int, @"io".err error); UnreadRune() (? error) }
	type @"math/big".nat []@"math/big".Word
	func (@"math/big".zÂ·2 @"math/big".nat) @"math/big".add (@"math/big".xÂ·3 @"math/big".nat, @"math/big".yÂ·4 @"math/big".nat) (? @"math/big".nat)
	func (@"math/big".zÂ·2 @"math/big".nat "esc:0x1") @"math/big".and (@"math/big".xÂ·3 @"math/big".nat "esc:0x0", @"math/big".yÂ·4 @"math/big".nat "esc:0x0") (? @"math/big".nat)
	func (@"math/big".zÂ·2 @"math/big".nat "esc:0x1") @"math/big".andNot (@"math/big".xÂ·3 @"math/big".nat "esc:0x0", @"math/big".yÂ·4 @"math/big".nat "esc:0x0") (? @"math/big".nat)
	func (@"math/big".zÂ·2 @"math/big".nat "esc:0x0") @"math/big".bit (@"math/big".iÂ·3 uint) (? uint) { var @"math/big".jÂ·4 int; ; @"math/big".jÂ·4 = int(@"math/big".iÂ·3 / 0x20); if @"math/big".jÂ·4 >= len(@"math/big".zÂ·2) { return 0x0 }; return uint(@"math/big".zÂ·2[@"math/big".jÂ·4] >> (@"math/big".iÂ·3 % 0x20) & @"math/big".Word(0x1)) }
	func (@"math/big".xÂ·2 @"math/big".nat "esc:0x0") @"math/big".bitLen () (? int)
	func (@"math/big".zÂ·2 @"math/big".nat "esc:0x0") @"math/big".bytes (@"math/big".bufÂ·3 []byte "esc:0x0") (@"math/big".iÂ·1 int)
	func (@"math/big".zÂ·1 @"math/big".nat "esc:0x0") @"math/big".clear ()
	func (@"math/big".xÂ·2 @"math/big".nat "esc:0x0") @"math/big".cmp (@"math/big".yÂ·3 @"math/big".nat "esc:0x0") (@"math/big".rÂ·1 int)
	func (@"math/big".qÂ·1 @"math/big".nat) @"math/big".convertWords (@"math/big".sÂ·2 []byte "esc:0x0", @"math/big".charsetÂ·3 string "esc:0x0", @"math/big".bÂ·4 @"math/big".Word, @"math/big".ndigitsÂ·5 int, @"math/big".bbÂ·6 @"math/big".Word, @"math/big".tableÂ·7 []@"math/big".divisor "esc:0x0")
	func (@"math/big".xÂ·2 @"math/big".nat "esc:0x0") @"math/big".decimalString () (? string)
	func (@"math/big".zÂ·3 @"math/big".nat) @"math/big".div (@"math/big".z2Â·4 @"math/big".nat, @"math/big".uÂ·5 @"math/big".nat, @"math/big".vÂ·6 @"math/big".nat) (@"math/big".qÂ·1 @"math/big".nat, @"math/big".rÂ·2 @"math/big".nat)
	func (@"math/big".zÂ·3 @"math/big".nat "esc:0x1") @"math/big".divLarge (@"math/big".uÂ·4 @"math/big".nat, @"math/big".uInÂ·5 @"math/big".nat, @"math/big".vÂ·6 @"math/big".nat) (@"math/big".qÂ·1 @"math/big".nat, @"math/big".rÂ·2 @"math/big".nat)
	func (@"math/big".zÂ·3 @"math/big".nat) @"math/big".divW (@"math/big".xÂ·4 @"math/big".nat, @"math/big".yÂ·5 @"math/big".Word) (@"math/big".qÂ·1 @"math/big".nat, @"math/big".rÂ·2 @"math/big".Word)
	func (@"math/big".zÂ·2 @"math/big".nat) @"math/big".expNN (@"math/big".xÂ·3 @"math/big".nat, @"math/big".yÂ·4 @"math/big".nat "esc:0x0", @"math/big".mÂ·5 @"math/big".nat) (? @"math/big".nat)
	func (@"math/big".zÂ·2 @"math/big".nat) @"math/big".expNNWindowed (@"math/big".xÂ·3 @"math/big".nat, @"math/big".yÂ·4 @"math/big".nat "esc:0x0", @"math/big".mÂ·5 @"math/big".nat) (? @"math/big".nat)
	func (@"math/big".zÂ·2 @"math/big".nat) @"math/big".expWW (@"math/big".xÂ·3 @"math/big".Word, @"math/big".yÂ·4 @"math/big".Word) (? @"math/big".nat)
	func (@"math/big".zÂ·2 @"math/big".nat "esc:0x1") @"math/big".make (@"math/big".nÂ·3 int) (? @"math/big".nat)
	func (@"math/big".xÂ·2 @"math/big".nat) @"math/big".modW (@"math/big".dÂ·3 @"math/big".Word) (@"math/big".rÂ·1 @"math/big".Word)
	func (@"math/big".zÂ·2 @"math/big".nat) @"math/big".mul (@"math/big".xÂ·3 @"math/big".nat, @"math/big".yÂ·4 @"math/big".nat) (? @"math/big".nat)
	func (@"math/big".zÂ·2 @"math/big".nat) @"math/big".mulAddWW (@"math/big".xÂ·3 @"math/big".nat, @"math/big".yÂ·4 @"math/big".Word, @"math/big".rÂ·5 @"math/big".Word) (? @"math/big".nat)
	func (@"math/big".zÂ·2 @"math/big".nat) @"math/big".mulRange (@"math/big".aÂ·3 uint64, @"math/big".bÂ·4 uint64) (? @"math/big".nat)
	func (@"math/big".zÂ·2 @"math/big".nat "esc:0x1") @"math/big".norm () (? @"math/big".nat)
	func (@"math/big".zÂ·2 @"math/big".nat "esc:0x1") @"math/big".or (@"math/big".xÂ·3 @"math/big".nat "esc:0x0", @"math/big".yÂ·4 @"math/big".nat "esc:0x0") (? @"math/big".nat)
	func (@"math/big".nÂ·2 @"math/big".nat) @"math/big".probablyPrime (@"math/big".repsÂ·3 int) (? bool)
	func (@"math/big".zÂ·2 @"math/big".nat "esc:0x1") @"math/big".random (@"math/big".randÂ·3 *@"math/rand".Rand, @"math/big".limitÂ·4 @"math/big".nat "esc:0x0", @"math/big".nÂ·5 int) (? @"math/big".nat)
	func (@"math/big".zÂ·4 @"math/big".nat) @"math/big".scan (@"math/big".rÂ·5 @"io".RuneScanner, @"math/big".baseÂ·6 int) (? @"math/big".nat, ? int, ? error)
	func (@"math/big".zÂ·2 @"math/big".nat "esc:0x1") @"math/big".set (@"math/big".xÂ·3 @"math/big".nat "esc:0x0") (? @"math/big".nat)
	func (@"math/big".zÂ·2 @"math/big".nat "esc:0x1") @"math/big".setBit (@"math/big".xÂ·3 @"math/big".nat "esc:0x0", @"math/big".iÂ·4 uint, @"math/big".bÂ·5 uint) (? @"math/big".nat)
	func (@"math/big".zÂ·2 @"math/big".nat "esc:0x1") @"math/big".setBytes (@"math/big".bufÂ·3 []byte "esc:0x0") (? @"math/big".nat)
	func (@"math/big".zÂ·2 @"math/big".nat "esc:0x1") @"math/big".setUint64 (@"math/big".xÂ·3 uint64) (? @"math/big".nat)
	func (@"math/big".zÂ·2 @"math/big".nat "esc:0x1") @"math/big".setWord (@"math/big".xÂ·3 @"math/big".Word) (? @"math/big".nat)
	func (@"math/big".zÂ·2 @"math/big".nat) @"math/big".shl (@"math/big".xÂ·3 @"math/big".nat, @"math/big".sÂ·4 uint) (? @"math/big".nat)
	func (@"math/big".zÂ·2 @"math/big".nat) @"math/big".shr (@"math/big".xÂ·3 @"math/big".nat, @"math/big".sÂ·4 uint) (? @"math/big".nat)
	func (@"math/big".xÂ·2 @"math/big".nat "esc:0x0") @"math/big".string (@"math/big".charsetÂ·3 string "esc:0x0") (? string)
	func (@"math/big".zÂ·2 @"math/big".nat) @"math/big".sub (@"math/big".xÂ·3 @"math/big".nat, @"math/big".yÂ·4 @"math/big".nat) (? @"math/big".nat)
	func (@"math/big".xÂ·2 @"math/big".nat "esc:0x0") @"math/big".trailingZeroBits () (? uint)
	func (@"math/big".zÂ·2 @"math/big".nat "esc:0x1") @"math/big".xor (@"math/big".xÂ·3 @"math/big".nat "esc:0x0", @"math/big".yÂ·4 @"math/big".nat "esc:0x0") (? @"math/big".nat)
	import fmt "fmt" // indirect
	type @"fmt".State interface { Flag(@"fmt".c int) (? bool); Precision() (@"fmt".prec int, @"fmt".ok bool); Width() (@"fmt".wid int, @"fmt".ok bool); Write(@"fmt".b []byte) (@"fmt".ret int, @"fmt".err error) }
	type @"fmt".ScanState interface { Read(@"fmt".buf []byte) (@"fmt".n int, @"fmt".err error); ReadRune() (@"fmt".r rune, @"fmt".size int, @"fmt".err error); SkipSpace(); Token(@"fmt".skipSpace bool, @"fmt".f func(? rune) (? bool)) (@"fmt".token []byte, @"fmt".err error); UnreadRune() (? error); Width() (@"fmt".wid int, @"fmt".ok bool) }
	type @"math/big".Int struct { @"math/big".neg bool; @"math/big".abs @"math/big".nat }
	func (@"math/big".zÂ·2 *@"math/big".Int) Abs (@"math/big".xÂ·3 *@"math/big".Int "esc:0x0") (? *@"math/big".Int)
	func (@"math/big".zÂ·2 *@"math/big".Int) Add (@"math/big".xÂ·3 *@"math/big".Int, @"math/big".yÂ·4 *@"math/big".Int) (? *@"math/big".Int)
	func (@"math/big".zÂ·2 *@"math/big".Int) And (@"math/big".xÂ·3 *@"math/big".Int, @"math/big".yÂ·4 *@"math/big".Int) (? *@"math/big".Int)
	func (@"math/big".zÂ·2 *@"math/big".Int) AndNot (@"math/big".xÂ·3 *@"math/big".Int, @"math/big".yÂ·4 *@"math/big".Int) (? *@"math/big".Int)
	func (@"math/big".zÂ·2 *@"math/big".Int) Binomial (@"math/big".nÂ·3 int64, @"math/big".kÂ·4 int64) (? *@"math/big".Int)
	func (@"math/big".xÂ·2 *@"math/big".Int) Bit (@"math/big".iÂ·3 int) (? uint)
	func (@"math/big".xÂ·2 *@"math/big".Int "esc:0x0") BitLen () (? int)
	func (@"math/big".xÂ·2 *@"math/big".Int "esc:0x0") Bits () (? []@"math/big".Word) { return @"math/big".xÂ·2.@"math/big".abs }
	func (@"math/big".xÂ·2 *@"math/big".Int "esc:0x0") Bytes () (? []byte)
	func (@"math/big".xÂ·2 *@"math/big".Int "esc:0x0") Cmp (@"math/big".yÂ·3 *@"math/big".Int "esc:0x0") (@"math/big".rÂ·1 int)
	func (@"math/big".zÂ·2 *@"math/big".Int) Div (@"math/big".xÂ·3 *@"math/big".Int, @"math/big".yÂ·4 *@"math/big".Int) (? *@"math/big".Int)
	func (@"math/big".zÂ·3 *@"math/big".Int) DivMod (@"math/big".xÂ·4 *@"math/big".Int, @"math/big".yÂ·5 *@"math/big".Int, @"math/big".mÂ·6 *@"math/big".Int) (? *@"math/big".Int, ? *@"math/big".Int)
	func (@"math/big".zÂ·2 *@"math/big".Int) Exp (@"math/big".xÂ·3 *@"math/big".Int, @"math/big".yÂ·4 *@"math/big".Int "esc:0x0", @"math/big".mÂ·5 *@"math/big".Int) (? *@"math/big".Int)
	func (@"math/big".xÂ·1 *@"math/big".Int "esc:0x0") Format (@"math/big".sÂ·2 @"fmt".State, @"math/big".chÂ·3 rune)
	func (@"math/big".zÂ·2 *@"math/big".Int) GCD (@"math/big".xÂ·3 *@"math/big".Int, @"math/big".yÂ·4 *@"math/big".Int, @"math/big".aÂ·5 *@"math/big".Int, @"math/big".bÂ·6 *@"math/big".Int) (? *@"math/big".Int)
	func (@"math/big".zÂ·2 *@"math/big".Int) GobDecode (@"math/big".bufÂ·3 []byte "esc:0x0") (? error)
	func (@"math/big".xÂ·3 *@"math/big".Int "esc:0x0") GobEncode () (? []byte, ? error)
	func (@"math/big".xÂ·2 *@"math/big".Int "esc:0x0") Int64 () (? int64)
	func (@"math/big".zÂ·2 *@"math/big".Int) Lsh (@"math/big".xÂ·3 *@"math/big".Int, @"math/big".nÂ·4 uint) (? *@"math/big".Int)
	func (@"math/big".zÂ·3 *@"math/big".Int "esc:0x0") MarshalJSON () (? []byte, ? error)
	func (@"math/big".zÂ·3 *@"math/big".Int "esc:0x0") MarshalText () (@"math/big".textÂ·1 []byte, @"math/big".errÂ·2 error)
	func (@"math/big".zÂ·2 *@"math/big".Int) Mod (@"math/big".xÂ·3 *@"math/big".Int, @"math/big".yÂ·4 *@"math/big".Int) (? *@"math/big".Int)
	func (@"math/big".zÂ·2 *@"math/big".Int) ModInverse (@"math/big".gÂ·3 *@"math/big".Int, @"math/big".pÂ·4 *@"math/big".Int) (? *@"math/big".Int)
	func (@"math/big".zÂ·2 *@"math/big".Int) Mul (@"math/big".xÂ·3 *@"math/big".Int, @"math/big".yÂ·4 *@"math/big".Int) (? *@"math/big".Int)
	func (@"math/big".zÂ·2 *@"math/big".Int) MulRange (@"math/big".aÂ·3 int64, @"math/big".bÂ·4 int64) (? *@"math/big".Int)
	func (@"math/big".zÂ·2 *@"math/big".Int) Neg (@"math/big".xÂ·3 *@"math/big".Int "esc:0x0") (? *@"math/big".Int)
	func (@"math/big".zÂ·2 *@"math/big".Int) Not (@"math/big".xÂ·3 *@"math/big".Int) (? *@"math/big".Int)
	func (@"math/big".zÂ·2 *@"math/big".Int) Or (@"math/big".xÂ·3 *@"math/big".Int, @"math/big".yÂ·4 *@"math/big".Int) (? *@"math/big".Int)
	func (@"math/big".xÂ·2 *@"math/big".Int) ProbablyPrime (@"math/big".nÂ·3 int) (? bool)
	func (@"math/big".zÂ·2 *@"math/big".Int) Quo (@"math/big".xÂ·3 *@"math/big".Int, @"math/big".yÂ·4 *@"math/big".Int) (? *@"math/big".Int)
	func (@"math/big".zÂ·3 *@"math/big".Int) QuoRem (@"math/big".xÂ·4 *@"math/big".Int, @"math/big".yÂ·5 *@"math/big".Int, @"math/big".rÂ·6 *@"math/big".Int) (? *@"math/big".Int, ? *@"math/big".Int)
	func (@"math/big".zÂ·2 *@"math/big".Int) Rand (@"math/big".rndÂ·3 *@"math/rand".Rand, @"math/big".nÂ·4 *@"math/big".Int "esc:0x0") (? *@"math/big".Int)
	func (@"math/big".zÂ·2 *@"math/big".Int) Rem (@"math/big".xÂ·3 *@"math/big".Int, @"math/big".yÂ·4 *@"math/big".Int) (? *@"math/big".Int)
	func (@"math/big".zÂ·2 *@"math/big".Int) Rsh (@"math/big".xÂ·3 *@"math/big".Int, @"math/big".nÂ·4 uint) (? *@"math/big".Int)
	func (@"math/big".zÂ·2 *@"math/big".Int) Scan (@"math/big".sÂ·3 @"fmt".ScanState, @"math/big".chÂ·4 rune) (? error)
	func (@"math/big".zÂ·2 *@"math/big".Int) Set (@"math/big".xÂ·3 *@"math/big".Int "esc:0x0") (? *@"math/big".Int)
	func (@"math/big".zÂ·2 *@"math/big".Int) SetBit (@"math/big".xÂ·3 *@"math/big".Int, @"math/big".iÂ·4 int, @"math/big".bÂ·5 uint) (? *@"math/big".Int)
	func (@"math/big".zÂ·2 *@"math/big".Int "esc:0x1") SetBits (@"math/big".absÂ·3 []@"math/big".Word) (? *@"math/big".Int)
	func (@"math/big".zÂ·2 *@"math/big".Int) SetBytes (@"math/big".bufÂ·3 []byte "esc:0x0") (? *@"math/big".Int)
	func (@"math/big".zÂ·2 *@"math/big".Int) SetInt64 (@"math/big".xÂ·3 int64) (? *@"math/big".Int)
	func (@"math/big".zÂ·3 *@"math/big".Int) SetString (@"math/big".sÂ·4 string, @"math/big".baseÂ·5 int) (? *@"math/big".Int, ? bool)
	func (@"math/big".zÂ·2 *@"math/big".Int) SetUint64 (@"math/big".xÂ·3 uint64) (? *@"math/big".Int)
	func (@"math/big".xÂ·2 *@"math/big".Int "esc:0x0") Sign () (? int) { if len(@"math/big".xÂ·2.@"math/big".abs) == 0x0 { return 0x0 }; if @"math/big".xÂ·2.@"math/big".neg { return -0x1 }; return 0x1 }
	func (@"math/big".xÂ·2 *@"math/big".Int "esc:0x0") String () (? string)
	func (@"math/big".zÂ·2 *@"math/big".Int) Sub (@"math/big".xÂ·3 *@"math/big".Int, @"math/big".yÂ·4 *@"math/big".Int) (? *@"math/big".Int)
	func (@"math/big".xÂ·2 *@"math/big".Int "esc:0x0") Uint64 () (? uint64) { if len(@"math/big".xÂ·2.@"math/big".abs) == 0x0 { return 0x0 }; var @"math/big".vÂ·3 uint64; ; @"math/big".vÂ·3 = uint64(@"math/big".xÂ·2.@"math/big".abs[0x0]); if true && len(@"math/big".xÂ·2.@"math/big".abs) > 0x1 { @"math/big".vÂ·3 |= uint64(@"math/big".xÂ·2.@"math/big".abs[0x1]) << 0x20 }; return @"math/big".vÂ·3 }
	func (@"math/big".zÂ·2 *@"math/big".Int) UnmarshalJSON (@"math/big".textÂ·3 []byte) (? error)
	func (@"math/big".zÂ·2 *@"math/big".Int) UnmarshalText (@"math/big".textÂ·3 []byte) (? error)
	func (@"math/big".zÂ·2 *@"math/big".Int) Xor (@"math/big".xÂ·3 *@"math/big".Int, @"math/big".yÂ·4 *@"math/big".Int) (? *@"math/big".Int)
	func (@"math/big".zÂ·2 *@"math/big".Int) @"math/big".binaryGCD (@"math/big".aÂ·3 *@"math/big".Int, @"math/big".bÂ·4 *@"math/big".Int) (? *@"math/big".Int)
	func (@"math/big".zÂ·4 *@"math/big".Int) @"math/big".scan (@"math/big".rÂ·5 @"io".RuneScanner, @"math/big".baseÂ·6 int) (? *@"math/big".Int, ? int, ? error)
	type @"crypto/elliptic".CurveParams struct { P *@"math/big".Int; N *@"math/big".Int; B *@"math/big".Int; Gx *@"math/big".Int; Gy *@"math/big".Int; BitSize int }
	func (@"crypto/elliptic".curveÂ·3 *@"crypto/elliptic".CurveParams) Add (@"crypto/elliptic".x1Â·4 *@"math/big".Int, @"crypto/elliptic".y1Â·5 *@"math/big".Int, @"crypto/elliptic".x2Â·6 *@"math/big".Int, @"crypto/elliptic".y2Â·7 *@"math/big".Int) (? *@"math/big".Int, ? *@"math/big".Int)
	func (@"crypto/elliptic".curveÂ·3 *@"crypto/elliptic".CurveParams) Double (@"crypto/elliptic".x1Â·4 *@"math/big".Int, @"crypto/elliptic".y1Â·5 *@"math/big".Int) (? *@"math/big".Int, ? *@"math/big".Int)
	func (@"crypto/elliptic".curveÂ·2 *@"crypto/elliptic".CurveParams) IsOnCurve (@"crypto/elliptic".xÂ·3 *@"math/big".Int, @"crypto/elliptic".yÂ·4 *@"math/big".Int) (? bool)
	func (@"crypto/elliptic".curveÂ·2 *@"crypto/elliptic".CurveParams "esc:0x1") Params () (? *@"crypto/elliptic".CurveParams) { return @"crypto/elliptic".curveÂ·2 }
	func (@"crypto/elliptic".curveÂ·3 *@"crypto/elliptic".CurveParams) ScalarBaseMult (@"crypto/elliptic".kÂ·4 []byte "esc:0x0") (? *@"math/big".Int, ? *@"math/big".Int)
	func (@"crypto/elliptic".curveÂ·3 *@"crypto/elliptic".CurveParams) ScalarMult (@"crypto/elliptic".BxÂ·4 *@"math/big".Int, @"crypto/elliptic".ByÂ·5 *@"math/big".Int, @"crypto/elliptic".kÂ·6 []byte "esc:0x0") (? *@"math/big".Int, ? *@"math/big".Int)
	func (@"crypto/elliptic".curveÂ·4 *@"crypto/elliptic".CurveParams) @"crypto/elliptic".addJacobian (@"crypto/elliptic".x1Â·5 *@"math/big".Int, @"crypto/elliptic".y1Â·6 *@"math/big".Int, @"crypto/elliptic".z1Â·7 *@"math/big".Int, @"crypto/elliptic".x2Â·8 *@"math/big".Int, @"crypto/elliptic".y2Â·9 *@"math/big".Int, @"crypto/elliptic".z2Â·10 *@"math/big".Int) (? *@"math/big".Int, ? *@"math/big".Int, ? *@"math/big".Int)
	func (@"crypto/elliptic".curveÂ·3 *@"crypto/elliptic".CurveParams) @"crypto/elliptic".affineFromJacobian (@"crypto/elliptic".xÂ·4 *@"math/big".Int, @"crypto/elliptic".yÂ·5 *@"math/big".Int, @"crypto/elliptic".zÂ·6 *@"math/big".Int) (@"crypto/elliptic".xOutÂ·1 *@"math/big".Int, @"crypto/elliptic".yOutÂ·2 *@"math/big".Int)
	func (@"crypto/elliptic".curveÂ·4 *@"crypto/elliptic".CurveParams) @"crypto/elliptic".doubleJacobian (@"crypto/elliptic".xÂ·5 *@"math/big".Int, @"crypto/elliptic".yÂ·6 *@"math/big".Int, @"crypto/elliptic".zÂ·7 *@"math/big".Int) (? *@"math/big".Int, ? *@"math/big".Int, ? *@"math/big".Int)
	type @"crypto/elliptic".Curve interface { Add(@"crypto/elliptic".x1 *@"math/big".Int, @"crypto/elliptic".y1 *@"math/big".Int, @"crypto/elliptic".x2 *@"math/big".Int, @"crypto/elliptic".y2 *@"math/big".Int) (@"crypto/elliptic".x *@"math/big".Int, @"crypto/elliptic".y *@"math/big".Int); Double(@"crypto/elliptic".x1 *@"math/big".Int, @"crypto/elliptic".y1 *@"math/big".Int) (@"crypto/elliptic".x *@"math/big".Int, @"crypto/elliptic".y *@"math/big".Int); IsOnCurve(@"crypto/elliptic".x *@"math/big".Int, @"crypto/elliptic".y *@"math/big".Int) (? bool); Params() (? *@"crypto/elliptic".CurveParams); ScalarBaseMult(@"crypto/elliptic".k []byte) (@"crypto/elliptic".x *@"math/big".Int, @"crypto/elliptic".y *@"math/big".Int); ScalarMult(@"crypto/elliptic".x1 *@"math/big".Int, @"crypto/elliptic".y1 *@"math/big".Int, @"crypto/elliptic".k []byte) (@"crypto/elliptic".x *@"math/big".Int, @"crypto/elliptic".y *@"math/big".Int) }
	type @"".PublicKey struct { ? @"crypto/elliptic".Curve; X *@"math/big".Int; Y *@"math/big".Int }
	type @"".PrivateKey struct { ? @"".PublicKey; D *@"math/big".Int }
	type @"io".Reader interface { Read(@"io".p []byte) (@"io".n int, @"io".err error) }
	func @"".GenerateKey (@"".cÂ·3 @"crypto/elliptic".Curve, @"".randÂ·4 @"io".Reader) (@"".privÂ·1 *@"".PrivateKey, @"".errÂ·2 error)
	func @"".Sign (@"".randÂ·4 @"io".Reader, @"".privÂ·5 *@"".PrivateKey, @"".hashÂ·6 []byte "esc:0x0") (@"".rÂ·1 *@"math/big".Int, @"".sÂ·2 *@"math/big".Int, @"".errÂ·3 error)
	func @"".Verify (@"".pubÂ·2 *@"".PublicKey, @"".hashÂ·3 []byte "esc:0x0", @"".rÂ·4 *@"math/big".Int, @"".sÂ·5 *@"math/big".Int) (? bool)
	func @"".init ()

$$
_go_.8          0           0     0     644     77663     `
go object windows 386 devel +ddfee9dfca20 Wed Apr 02 21:05:41 2014 -0700 X:precisestack

!
  go13ld"crypto/elliptic.aio.amath/big.a ş&"".randFieldElement     ‚d‹   ‹	;!w1ÿ¸   è    ëåƒì8ÇD$P    ÇD$T    ÇD$P    ÇD$T    ÇD$L    ‹\$@‰$‹\$<‹[ ÿÓ‹D$‰D$(‹h‰éÁùÁééÁùƒÁÇ$    ‰È™‰D$‰T$‰È™‰D$‰T$è    ‹T$‹L$‹D$‹\$D‰$‹\$H‰\$‰T$,‰T$‰L$0‰L$‰D$4‰D$è    ‹\$‰\$P‹\$‰\$Tƒ|$P tƒÄ8ÃÇ$    è    ‹\$‰$‹\$,‰\$‹\$0‰\$‹\$4‰\$è    ‹\$‰\$LÇ$    è    ‹\$‰$‹\$(‹k‰l$‹    ‰\$è    ‹L$L‹D$‰$‰L$‰D$è    ‹D$L‰$‰D$‹    ‰\$è    ƒÄ8Ã*À  0runtime.morestack_noctxt   è˜  type.[]uint8   À  "runtime.makeslice   À  io.ReadFull   Ò˜  "type.math/big.Int   ÜÀ  runtime.new   ¤À  0math/big.(*Int).SetBytes   Â˜  "type.math/big.Int   ÌÀ  runtime.new   ü˜  "".one   À  &math/big.(*Int).Sub   ¾À  &math/big.(*Int).Mod   à˜  "".one   òÀ  &math/big.(*Int).Add   8p"".autotmp_0004 'type.int "".autotmp_0003  type.int "".autotmp_0002  $type.*math/big.Int "".b type.[]uint8 "".params Btype.*crypto/elliptic.CurveParams "".err (type.error "".k  $type.*math/big.Int "".rand type.io.Reader "".c  4type.crypto/elliptic.Curve pÇopšo  .LFE<85 & T8BAZ3f " T:8'$!J     TgclocalsÂ·808d8a83f3ee88717356789ffec2964a TgclocalsÂ·14bf9716750c0a5ff98c507debfddc7e     v/home/14/ren/source/golang/go/src/pkg/crypto/ecdsa/ecdsa.goş"".GenerateKey  €  öd‹   ‹	;!w1ÿ¸   è    ëåƒì ÇD$8    ÇD$<    ÇD$8    ÇD$<    ÇD$4    ‹\$$‰$‹\$(‰\$‹\$,‰\$‹\$0‰\$è    ‹\$‰\$‹\$‰\$8‹\$‰\$<ƒ|$8 tƒÄ ÃÇ$    è    ‹L$‹D$‹l$$‰(‹l$(‰h‰D$4‰H‰$è    ‹T$‹L$‹D$‰T$‰L$‰D$‹\$(‰$‹\$$‹[$ÿÓ‹D$4‹l$‰h‹l$‰hƒÄ Ã
*À  0runtime.morestack_noctxt   ÌÀ  &"".randFieldElement    ˜  $type."".PrivateKey   ªÀ  runtime.new   òÀ  *math/big.(*Int).Bytes   8@
"".k $type.*math/big.Int "".err (type.error "".priv  &type.*"".PrivateKey "".rand type.io.Reader "".c  4type.crypto/elliptic.Curve @n?@m? € &lF<B	  ”	F21  e/$H     TgclocalsÂ·b7ba104b9941720a8d38022ba44cdb96 TgclocalsÂ·36f19a0b3c230d1e5b47f16afdf9b276     v/home/14/ren/source/golang/go/src/pkg/crypto/ecdsa/ecdsa.goş"".hashToInt  à  Äd‹   ‹	;!w1ÿ¸   è    ëåƒì0‹\$D‰$‹\$@‹[ ÿÓ‹\$‹k‰,$è    ‹D$‰D$ƒÀ‰ÃÁûÁëÃÁû‰Ø‹L$89Ù~‹L$<9Ùrt‹\$4‰\$4‰D$8‰L$<Ç$    è    ‹\$‰$‹\$4‰\$‹\$8‰\$‹\$<‰\$è    ‹L$‹D$8Áà+D$ƒø ~‰$‰L$,‰L$‰D$è    ‹L$,‰L$HƒÄ0Ãè    *À  0runtime.morestack_noctxt   rÀ  ,math/big.(*Int).BitLen   ô˜  "type.math/big.Int   şÀ  runtime.new   ÆÀ  0math/big.(*Int).SetBytes   –À  &math/big.(*Int).Rsh   ¸À  $runtime.panicslice   0`"".autotmp_0019  type.int "".autotmp_0017 type.uint32 "".autotmp_0016  type.int "".autotmp_0014 type.int "".excess 'type.int "".ret $type.*math/big.Int "".orderBytes 7type.int "".orderBits /type.int "".~r2 ($type.*math/big.Int "".c 4type.crypto/elliptic.Curve "".hash  type.[]uint8 `¼_` ğ 0’#4  ,PX  ,     TgclocalsÂ·c6e1585377db5e53e487dd81250187f3 TgclocalsÂ·e1ae6533a9e39048ba0735a2264ce16a     v/home/14/ren/source/golang/go/src/pkg/crypto/ecdsa/ecdsa.goş"".Sign  à	  Ú	d‹   ‹	;!w1ÿ¸(   è    ëåƒì@ÇD$d    ÇD$h    ÇD$d    ÇD$h    ÇD$`    ‹\$Lƒû „  ‹‹k‰l$<‰,$‰L$8‹Y ÿÓ‹\$‹k‰l$4‹\$8‰$‹\$<‰\$‹\$D‰\$‹\$H‰\$è    ‹\$‰\$,‹\$‰\$d‹\$‰\$hƒ|$d tÇD$\    ƒÄ@ÃÇ$    è    ‹\$‰$‹\$,‰\$‹\$4‰\$è    ‹\$‰\$(‹\$,‰$è    ‹|$‹t$‹T$‹\$Lƒû „H  ‹‹k‰|$‰t$‰T$‰,$‹Y$ÿÓ‹D$‰$‰D$\‰D$‹\$4‰\$è    ‹D$\‹hƒı …ç   1Àƒø „ÿÿÿ‹\$P‰$‹\$T‰\$‹\$X‰\$‹\$8‰\$‹\$<‰\$è    ‹\$‰\$0Ç$    è    ‹\$‰$‹\$L‹k‰l$‹\$\‰\$è    ‹D$‰$‰D$`‰D$‹\$0‰\$è    ‹D$`‰$‰D$‹\$(‰\$è    ‹D$`‰$‰D$‹\$4‰\$è    ‹D$`‹hƒı u1Àƒø „JşÿÿƒÄ@Ã¶€û t¸ÿÿÿÿëä¸   ëİ¶€û t
¸ÿÿÿÿé	ÿÿÿ¸   éÿşÿÿ‰é±şÿÿ‰éæıÿÿ*À  0runtime.morestack_noctxt   ¦À  &"".randFieldElement   Š˜  "type.math/big.Int   ”À  runtime.new   ÌÀ  4math/big.(*Int).ModInverse   ôÀ  *math/big.(*Int).Bytes   À  &math/big.(*Int).Mod   À  "".hashToInt   ¼˜  "type.math/big.Int   ÆÀ  runtime.new   „À  &math/big.(*Int).Mul   ¼À  &math/big.(*Int).Add   ìÀ  &math/big.(*Int).Mul   œÀ  &math/big.(*Int).Mod   P€"".autotmp_0032  $type.*math/big.Int "".autotmp_0031  $type.*math/big.Int "".~r0 ?type.int "".~r0 Gtype.int "".e $type.*math/big.Int "".kInv /$type.*math/big.Int "".k '$type.*math/big.Int "".N $type.*math/big.Int "".c 4type.crypto/elliptic.Curve "".err @type.error "".s 8$type.*math/big.Int "".r 0$type.*math/big.Int "".hash type.[]uint8 "".priv &type.*"".PrivateKey "".rand  type.io.Reader $€£€ê€C ğ \¸F
<0B
4/
	
 ( fa`21rÉ * f,70NG;{     TgclocalsÂ·f5dfdf0c4f887e519cd89297c4c34bb9 TgclocalsÂ·80c158c520bd0c96ac6fc57c457f26fe     v/home/14/ren/source/golang/go/src/pkg/crypto/ecdsa/ecdsa.goş"".Verify  €  èd‹   ‹	;!w1ÿ¸   è    ëåƒì`‹\$dƒû „  ‹‹k‰l$\‰,$‰L$X‹Y ÿÓ‹T$t‹\$‹s‹jƒı …º  1Àƒø „Š  ‹D$x‹hƒı …ƒ  1Àƒø „o  ‰$‰t$T‰t$è    ‹\$ƒû I  ‹\$x‰$‹\$T‰\$è    ‹\$ƒû (  ‹\$h‰$‹\$l‰\$‹\$p‰\$‹\$X‰\$‹\$\‰\$è    ‹\$‰\$PÇ$    è    ‹\$‰$‹\$x‰\$‹\$T‰\$è    ‹L$P‹D$‰$‰L$‰D$D‰D$è    ‹D$‰$‰D$L‰D$‹\$T‰\$è    ‹D$D‰$‹\$t‰\$‰D$è    ‹D$‰$‰D$H‰D$‹\$T‰\$è    ‹\$L‰$è    ‹T$‹L$‹D$‰T$‰L$‰D$‹\$\‰$‹\$X‹[$ÿÓ‹\$‰\$<‹\$‰\$8‹\$H‰$è    ‹t$d‹T$‹L$‹D$‹n‰l$‹n‰l$‰T$‰L$‰D$‹\$\‰$‹\$X‹[(ÿÓ‹L$‹D$‹\$<‰\$‹\$8‰\$‰L$‰D$‹\$\‰$‹\$X‹[ÿÓ‹L$‹T$‹iƒı uz1Àƒø u‹jƒı uU1Àƒø u	ÆD$| ƒÄ`Ã‰$‰L$@‰L$‹\$T‰\$è    ‹\$@‰$‹\$t‰\$è    ‹\$ƒû t	ÆD$| ƒÄ`ÃÆD$|ëõ¶€û t¸ÿÿÿÿë¸   ë—¶€û t
¸ÿÿÿÿévÿÿÿ¸   élÿÿÿÆD$| ƒÄ`ÃÆD$| ƒÄ`Ã¶€û t
¸ÿÿÿÿémıÿÿ¸   écıÿÿ¶€û t
¸ÿÿÿÿé6ıÿÿ¸   é,ıÿÿ‰é÷üÿÿ*À  0runtime.morestack_noctxt   ’À  &math/big.(*Int).Cmp   ÔÀ  &math/big.(*Int).Cmp   ÆÀ  "".hashToInt   ä˜  "type.math/big.Int   îÀ  runtime.new   ¦À  4math/big.(*Int).ModInverse   ŞÀ  &math/big.(*Int).Mul   –À  &math/big.(*Int).Mod   ÆÀ  &math/big.(*Int).Mul   şÀ  &math/big.(*Int).Mod   –À  *math/big.(*Int).Bytes   À  *math/big.(*Int).Bytes   €
À  &math/big.(*Int).Mod   ¨
À  &math/big.(*Int).Cmp   8À2"".autotmp_0047  type.int "".autotmp_0046  type.[]uint8 "".autotmp_0044  $type.*math/big.Int "".autotmp_0043  $type.*math/big.Int "".autotmp_0042  $type.*math/big.Int "".autotmp_0040 Wtype.int "".autotmp_0039  type.int "".~r0 otype.int "".~r0 gtype.int "".~r0 type.int "".~r0 wtype.int "".x ?$type.*math/big.Int 
"".y1 O$type.*math/big.Int 
"".x1 G$type.*math/big.Int 
"".u2 /$type.*math/big.Int 
"".u1 '$type.*math/big.Int "".w 7$type.*math/big.Int "".e $type.*math/big.Int "".N $type.*math/big.Int "".c 4type.crypto/elliptic.Curve "".~r4 0type.bool "".s ($type.*math/big.Int "".r  $type.*math/big.Int "".hash type.[]uint8 "".pub  $type.*"".PublicKey >ÀÍ¿À=¿ÀA¿À¿ÀK À `‚2>40DN0	-2		8 4 >²º21TBA.:9ƒ 8 >Jn8DmD­     TgclocalsÂ·ddbde40f3260d0b9c4588035a25eea26 TgclocalsÂ·a28adf168859d61f2756471f31e52ce5     v/home/14/ren/source/golang/go/src/pkg/crypto/ecdsa/ecdsa.goş"".init     ”d‹   ‹	;!w1ÿ1Àè    ëèƒì¶    €ø t€øuƒÄÃè    Æ    è    è    è    Ç$    è    ‹\$‰$ÇD$   ÇD$    è    ‹\$‰    Æ    ƒÄÃ$À  0runtime.morestack_noctxt   <˜  "".initdoneÂ·   bÀ  "runtime.throwinit   r˜  "".initdoneÂ·   ~À  math/big.init   ˆÀ  io.init   ’À  (crypto/elliptic.init    ˜  "type.math/big.Int   ªÀ  runtime.new   âÀ  0math/big.(*Int).SetInt64   ö˜  "".one   ‚˜  "".initdoneÂ·        Y  ¸Mó2ô  0$7 
 0`     TgclocalsÂ·3280bececceccd33cb74587feedb1f9f TgclocalsÂ·3280bececceccd33cb74587feedb1f9f     v/home/14/ren/source/golang/go/src/pkg/crypto/ecdsa/ecdsa.goş.type..hash."".PublicKey €  úd‹   ‹	;!w1ÿ¸   è    ëåƒì‹\$‰$ÇD$   ‹\$‰\$ƒ|$ t9è    ‹\$‰$ÇD$   ‹\$‰\$ƒ|$ tƒD$è    ƒÄÃ‰    ëê‰    ë¿*À  0runtime.morestack_noctxt   zÀ  "runtime.interhash   ÊÀ  runtime.memhash   "".p $type.*"".PublicKey "".s type.uintptr "".h  type.*uintptr N € €  <# 
 <D     TgclocalsÂ·c34189e3b824b0bbe5cf2ca4e567d435 TgclocalsÂ·3280bececceccd33cb74587feedb1f9f     v/home/14/ren/source/golang/go/src/pkg/crypto/ecdsa/ecdsa.goş*type..eq."".PublicKey à  Şd‹   ‹	;!w1ÿ¸   è    ëåƒì(‹T$,‹\$8ƒû t}‹‹k‰l$$‹\$4ƒû tg‹‹{9ÈuW‰$‰|$‰L$‹l$$‰l$è    ‹|$8‹t$4‹T$,¶\$€û t)‹N‹o9étÆ ƒÄ(Ã‹F‹o9ètÆ ƒÄ(ÃÆƒÄ(ÃÆ ƒÄ(Ã‰ë•‰é|ÿÿÿ*À  0runtime.morestack_noctxt   ´À  runtime.ifaceeq    P
"".autotmp_0057 4type.crypto/elliptic.Curve "".q $type.*"".PublicKey "".p $type.*"".PublicKey "".s type.uintptr 
"".eq  type.*bool *PfOPOPOPOP ° °  Y*)F 
 YW     TgclocalsÂ·42ea2d2340f90cf3f379f66fe4b2d382 TgclocalsÂ·7b2d1dc8e692ba633cb2c876407e20f2     v/home/14/ren/source/golang/go/src/pkg/crypto/ecdsa/ecdsa.goş&"".(*PublicKey).Add €  úd‹   ‹	;!w1ÿ¸   è    ëåƒìƒA ‹\$ ƒû tN‹‹k‹\$$‰\$‹\$(‰\$‹\$,‰\$‹\$0‰\$‰,$‹YÿÓ‹L$‹D$‰L$4‰D$8d‹   ‹	ƒi ƒÄÃ‰ë®*À  0runtime.morestack_noctxt   88"crypto/elliptic.y 0$type.*math/big.Int "crypto/elliptic.x ($type.*math/big.Int $crypto/elliptic.y2  $type.*math/big.Int $crypto/elliptic.x2 $type.*math/big.Int $crypto/elliptic.y1 $type.*math/big.Int $crypto/elliptic.x1 $type.*math/big.Int ""..this  $type.*"".PublicKey 8Z78 € €  V:9( 
 V*     TgclocalsÂ·be52d99fd4fc187ec6a3cd1eab5661d9 TgclocalsÂ·3280bececceccd33cb74587feedb1f9f     v/home/14/ren/source/golang/go/src/pkg/crypto/ecdsa/ecdsa.goş,"".(*PublicKey).Double à  Úd‹   ‹	;!w1ÿ¸   è    ëåƒìƒA‹\$ƒû t>‹‹k‹\$‰\$‹\$ ‰\$‰,$‹YÿÓ‹L$‹D$‰L$$‰D$(d‹   ‹	ƒiƒÄÃ‰ë¾*À  0runtime.morestack_noctxt   ((
"crypto/elliptic.y  $type.*math/big.Int "crypto/elliptic.x $type.*math/big.Int $crypto/elliptic.y1 $type.*math/big.Int $crypto/elliptic.x1 $type.*math/big.Int ""..this  $type.*"".PublicKey (J'( p p  F*)( 
 F*     TgclocalsÂ·6e5d4a330d25067342b1b461a5d19024 TgclocalsÂ·3280bececceccd33cb74587feedb1f9f     v/home/14/ren/source/golang/go/src/pkg/crypto/ecdsa/ecdsa.goş2"".(*PublicKey).IsOnCurve à  Ìd‹   ‹	;!w1ÿ¸   è    ëåƒìƒA‹\$ƒû t7‹‹k‹\$‰\$‹\$‰\$‰,$‹YÿÓ¶\$ˆ\$ d‹   ‹	ƒiƒÄÃ‰ëÅ*À  0runtime.morestack_noctxt     "".~r3 type.bool "crypto/elliptic.y $type.*math/big.Int "crypto/elliptic.x $type.*math/big.Int ""..this  $type.*"".PublicKey  C  p p  F"!( 
 F*     TgclocalsÂ·8d11a518189555fd7f3bac3cc6ad264c TgclocalsÂ·3280bececceccd33cb74587feedb1f9f     v/home/14/ren/source/golang/go/src/pkg/crypto/ecdsa/ecdsa.goş,"".(*PublicKey).Params À  ªd‹   ‹	;!w1ÿ¸   è    ëåƒìƒA‹\$ƒû t&‹‹k‰,$‹Y ÿÓ‹\$‰\$d‹   ‹	ƒiƒÄÃ‰ëÖ*À  0runtime.morestack_noctxt   "".~r1 Btype.*crypto/elliptic.CurveParams ""..this  $type.*"".PublicKey 2 ` `  6( 
 6*     TgclocalsÂ·06cab038d51064a089bda21fa03e00f7 TgclocalsÂ·3280bececceccd33cb74587feedb1f9f     v/home/14/ren/source/golang/go/src/pkg/crypto/ecdsa/ecdsa.goş<"".(*PublicKey).ScalarBaseMult €  êd‹   ‹	;!w1ÿ¸   è    ëåƒìƒA‹\$ƒû tF‹‹k‹\$ ‰\$‹\$$‰\$‹\$(‰\$‰,$‹Y$ÿÓ‹L$‹D$‰L$,‰D$0d‹   ‹	ƒiƒÄÃ‰ë¶*À  0runtime.morestack_noctxt   00"crypto/elliptic.y ($type.*math/big.Int "crypto/elliptic.x  $type.*math/big.Int "crypto/elliptic.k type.[]uint8 ""..this  $type.*"".PublicKey 0R/0 € €  N210 
 N2     TgclocalsÂ·f7455b879dcc824579f14b4bd8303508 TgclocalsÂ·3280bececceccd33cb74587feedb1f9f     v/home/14/ren/source/golang/go/src/pkg/crypto/ecdsa/ecdsa.goş4"".(*PublicKey).ScalarMult    Šd‹   ‹	;!w1ÿ¸    è    ëåƒì ƒA$‹\$$ƒû tV‹‹k‹\$(‰\$‹\$,‰\$‹\$0‰\$‹\$4‰\$‹\$8‰\$‰,$‹Y(ÿÓ‹L$‹D$‰L$<‰D$@d‹   ‹	ƒi$ƒÄ Ã‰ë¦*À  0runtime.morestack_noctxt   @@"crypto/elliptic.y 8$type.*math/big.Int "crypto/elliptic.x 0$type.*math/big.Int "crypto/elliptic.k type.[]uint8 $crypto/elliptic.y1 $type.*math/big.Int $crypto/elliptic.x1 $type.*math/big.Int ""..this  $type.*"".PublicKey @b?@    ^BA0 
 ^2     TgclocalsÂ·7388aa65ec08dc6463e1b90d8823688a TgclocalsÂ·3280bececceccd33cb74587feedb1f9f     v/home/14/ren/source/golang/go/src/pkg/crypto/ecdsa/ecdsa.goş "".PublicKey.Add €  æd‹   ‹	;!w1ÿ¸(   è    ëåƒìƒA ‹L$ ‹D$$‹\$0‰\$‹\$4‰\$‹\$8‰\$‹\$<‰\$‰$‹YÿÓ‹L$‹D$‰L$@‰D$Dd‹   ‹	ƒi ƒÄÃ*À  0runtime.morestack_noctxt   P8"crypto/elliptic.y H$type.*math/big.Int "crypto/elliptic.x @$type.*math/big.Int $crypto/elliptic.y2 8$type.*math/big.Int $crypto/elliptic.x2 0$type.*math/big.Int $crypto/elliptic.y1 ($type.*math/big.Int $crypto/elliptic.x1  $type.*math/big.Int ""..this  "type."".PublicKey 8T7 € €  P:9. 
 P0     TgclocalsÂ·78ad52f947c0f9e54dd0fb4377b33085 TgclocalsÂ·3280bececceccd33cb74587feedb1f9f     v/home/14/ren/source/golang/go/src/pkg/crypto/ecdsa/ecdsa.goş&"".PublicKey.Double à  Æd‹   ‹	;!w1ÿ¸    è    ëåƒìƒA‹L$‹D$‹\$(‰\$‹\$,‰\$‰$‹YÿÓ‹L$‹D$‰L$0‰D$4d‹   ‹	ƒiƒÄÃ*À  0runtime.morestack_noctxt   @(
"crypto/elliptic.y 8$type.*math/big.Int "crypto/elliptic.x 0$type.*math/big.Int $crypto/elliptic.y1 ($type.*math/big.Int $crypto/elliptic.x1  $type.*math/big.Int ""..this  "type."".PublicKey (D' p p  @*). 
 @0     TgclocalsÂ·2c26e9496b1c078fc62b3f021ed30e75 TgclocalsÂ·3280bececceccd33cb74587feedb1f9f     v/home/14/ren/source/golang/go/src/pkg/crypto/ecdsa/ecdsa.goş,"".PublicKey.IsOnCurve À  ¸d‹   ‹	;!w1ÿ¸   è    ëåƒìƒA‹L$‹D$‹\$$‰\$‹\$(‰\$‰$‹YÿÓ¶\$ˆ\$,d‹   ‹	ƒiƒÄÃ*À  0runtime.morestack_noctxt   8 "".~r3 0type.bool "crypto/elliptic.y ($type.*math/big.Int "crypto/elliptic.x  $type.*math/big.Int ""..this  "type."".PublicKey  = ` `  @"! 
 @      TgclocalsÂ·533e41f03c38242213357bdf241c642f TgclocalsÂ·3280bececceccd33cb74587feedb1f9f     v/home/14/ren/source/golang/go/src/pkg/crypto/ecdsa/ecdsa.goş&"".PublicKey.Params    –d‹   ‹	;!w1ÿ¸   è    ëåƒìƒA‹L$‹\$‰$‹Y ÿÓ‹\$‰\$d‹   ‹	ƒiƒÄÃ*À  0runtime.morestack_noctxt   ("".~r1  Btype.*crypto/elliptic.CurveParams ""..this  "type."".PublicKey , P P  0 
 0      TgclocalsÂ·564befda8e2e8cc7f35f6bc1d3c5e0a6 TgclocalsÂ·3280bececceccd33cb74587feedb1f9f     v/home/14/ren/source/golang/go/src/pkg/crypto/ecdsa/ecdsa.goş6"".PublicKey.ScalarBaseMult à  Öd‹   ‹	;!w1ÿ¸$   è    ëåƒìƒA‹L$‹D$ ‹\$,‰\$‹\$0‰\$‹\$4‰\$‰$‹Y$ÿÓ‹L$‹D$‰L$8‰D$<d‹   ‹	ƒiƒÄÃ*À  0runtime.morestack_noctxt   H0"crypto/elliptic.y @$type.*math/big.Int "crypto/elliptic.x 8$type.*math/big.Int "crypto/elliptic.k  type.[]uint8 ""..this  "type."".PublicKey 0L/ p p  H21& 
 H(     TgclocalsÂ·47970fecb85752c2006cb09cd4115497 TgclocalsÂ·3280bececceccd33cb74587feedb1f9f     v/home/14/ren/source/golang/go/src/pkg/crypto/ecdsa/ecdsa.goş."".PublicKey.ScalarMult €  öd‹   ‹	;!w1ÿ¸,   è    ëåƒì ƒA$‹L$$‹D$(‹\$4‰\$‹\$8‰\$‹\$<‰\$‹\$@‰\$‹\$D‰\$‰$‹Y(ÿÓ‹L$‹D$‰L$H‰D$Ld‹   ‹	ƒi$ƒÄ Ã*À  0runtime.morestack_noctxt   X@"crypto/elliptic.y P$type.*math/big.Int "crypto/elliptic.x H$type.*math/big.Int "crypto/elliptic.k 0type.[]uint8 $crypto/elliptic.y1 ($type.*math/big.Int $crypto/elliptic.x1  $type.*math/big.Int ""..this  "type."".PublicKey @\? € €  XBA& 
 X(     TgclocalsÂ·061982756bec02206530e2020a77f696 TgclocalsÂ·3280bececceccd33cb74587feedb1f9f     v/home/14/ren/source/golang/go/src/pkg/crypto/ecdsa/ecdsa.goş0type..hash."".PrivateKey €  úd‹   ‹	;!w1ÿ¸   è    ëåƒì‹\$‰$ÇD$   ‹\$‰\$ƒ|$ t9è    ‹\$‰$ÇD$   ‹\$‰\$ƒ|$ tƒD$è    ƒÄÃ‰    ëê‰    ë¿*À  0runtime.morestack_noctxt   zÀ  .type..hash."".PublicKey   ÊÀ  runtime.memhash   "".p &type.*"".PrivateKey "".s type.uintptr "".h  type.*uintptr N € €  d 
 <D     TgclocalsÂ·c34189e3b824b0bbe5cf2ca4e567d435 TgclocalsÂ·3280bececceccd33cb74587feedb1f9f     v/home/14/ren/source/golang/go/src/pkg/crypto/ecdsa/ecdsa.goş,type..eq."".PrivateKey    ’d‹   ‹	;!w1ÿ¸   è    ëåƒì$‹T$0ƒú „—   ‹D$4ƒø „ƒ   ‰D$‹‹x‰T$ ‹‹r9Èub‰$‰t$‰L$‰|$è    ‹t$ ‹T$¶\$€û t<‹N‹j9éu2‹N‹j9éu(‹\$0‹K‹\$4‹k9ét‹\$(Æ ƒÄ$Ã‹\$(ÆƒÄ$Ã‹\$(Æ ƒÄ$Ã‰ évÿÿÿ‰ébÿÿÿ*À  0runtime.morestack_noctxt   ¼À  runtime.ifaceeq    H"".autotmp_0102 $type.*"".PublicKey "".autotmp_0101 $type.*"".PublicKey "".q &type.*"".PrivateKey "".p &type.*"".PrivateKey "".s type.uintptr 
"".eq  type.*bool $H†GH
GH
GH Ğ Ğ  ]*)f 
 ]s     TgclocalsÂ·e883500196cbb0efce3121f314db1635 TgclocalsÂ·1c5b1c90a4c2549bb9ca6a7854f35d0e     v/home/14/ren/source/golang/go/src/pkg/crypto/ecdsa/ecdsa.goş("".(*PrivateKey).Add €  úd‹   ‹	;!w1ÿ¸   è    ëåƒìƒA ‹\$ ƒû tN‹‹k‹\$$‰\$‹\$(‰\$‹\$,‰\$‹\$0‰\$‰,$‹YÿÓ‹L$‹D$‰L$4‰D$8d‹   ‹	ƒi ƒÄÃ‰ë®*À  0runtime.morestack_noctxt   88"crypto/elliptic.y 0$type.*math/big.Int "crypto/elliptic.x ($type.*math/big.Int $crypto/elliptic.y2  $type.*math/big.Int $crypto/elliptic.x2 $type.*math/big.Int $crypto/elliptic.y1 $type.*math/big.Int $crypto/elliptic.x1 $type.*math/big.Int ""..this  &type.*"".PrivateKey 8Z78 € €  V:9( 
 V*     TgclocalsÂ·be52d99fd4fc187ec6a3cd1eab5661d9 TgclocalsÂ·3280bececceccd33cb74587feedb1f9f     v/home/14/ren/source/golang/go/src/pkg/crypto/ecdsa/ecdsa.goş."".(*PrivateKey).Double à  Úd‹   ‹	;!w1ÿ¸   è    ëåƒìƒA‹\$ƒû t>‹‹k‹\$‰\$‹\$ ‰\$‰,$‹YÿÓ‹L$‹D$‰L$$‰D$(d‹   ‹	ƒiƒÄÃ‰ë¾*À  0runtime.morestack_noctxt   ((
"crypto/elliptic.y  $type.*math/big.Int "crypto/elliptic.x $type.*math/big.Int $crypto/elliptic.y1 $type.*math/big.Int $crypto/elliptic.x1 $type.*math/big.Int ""..this  &type.*"".PrivateKey (J'( p p  F*)( 
 F*     TgclocalsÂ·6e5d4a330d25067342b1b461a5d19024 TgclocalsÂ·3280bececceccd33cb74587feedb1f9f     v/home/14/ren/source/golang/go/src/pkg/crypto/ecdsa/ecdsa.goş4"".(*PrivateKey).IsOnCurve à  Ìd‹   ‹	;!w1ÿ¸   è    ëåƒìƒA‹\$ƒû t7‹‹k‹\$‰\$‹\$‰\$‰,$‹YÿÓ¶\$ˆ\$ d‹   ‹	ƒiƒÄÃ‰ëÅ*À  0runtime.morestack_noctxt     "".~r3 type.bool "crypto/elliptic.y $type.*math/big.Int "crypto/elliptic.x $type.*math/big.Int ""..this  &type.*"".PrivateKey  C  p p  F"!( 
 F*     TgclocalsÂ·8d11a518189555fd7f3bac3cc6ad264c TgclocalsÂ·3280bececceccd33cb74587feedb1f9f     v/home/14/ren/source/golang/go/src/pkg/crypto/ecdsa/ecdsa.goş."".(*PrivateKey).Params À  ªd‹   ‹	;!w1ÿ¸   è    ëåƒìƒA‹\$ƒû t&‹‹k‰,$‹Y ÿÓ‹\$‰\$d‹   ‹	ƒiƒÄÃ‰ëÖ*À  0runtime.morestack_noctxt   "".~r1 Btype.*crypto/elliptic.CurveParams ""..this  &type.*"".PrivateKey 2 ` `  6( 
 6*     TgclocalsÂ·06cab038d51064a089bda21fa03e00f7 TgclocalsÂ·3280bececceccd33cb74587feedb1f9f     v/home/14/ren/source/golang/go/src/pkg/crypto/ecdsa/ecdsa.goş>"".(*PrivateKey).ScalarBaseMult €  êd‹   ‹	;!w1ÿ¸   è    ëåƒìƒA‹\$ƒû tF‹‹k‹\$ ‰\$‹\$$‰\$‹\$(‰\$‰,$‹Y$ÿÓ‹L$‹D$‰L$,‰D$0d‹   ‹	ƒiƒÄÃ‰ë¶*À  0runtime.morestack_noctxt   00"crypto/elliptic.y ($type.*math/big.Int "crypto/elliptic.x  $type.*math/big.Int "crypto/elliptic.k type.[]uint8 ""..this  &type.*"".PrivateKey 0R/0 € €  N210 
 N2     TgclocalsÂ·f7455b879dcc824579f14b4bd8303508 TgclocalsÂ·3280bececceccd33cb74587feedb1f9f     v/home/14/ren/source/golang/go/src/pkg/crypto/ecdsa/ecdsa.goş6"".(*PrivateKey).ScalarMult    Šd‹   ‹	;!w1ÿ¸    è    ëåƒì ƒA$‹\$$ƒû tV‹‹k‹\$(‰\$‹\$,‰\$‹\$0‰\$‹\$4‰\$‹\$8‰\$‰,$‹Y(ÿÓ‹L$‹D$‰L$<‰D$@d‹   ‹	ƒi$ƒÄ Ã‰ë¦*À  0runtime.morestack_noctxt   @@"crypto/elliptic.y 8$type.*math/big.Int "crypto/elliptic.x 0$type.*math/big.Int "crypto/elliptic.k type.[]uint8 $crypto/elliptic.y1 $type.*math/big.Int $crypto/elliptic.x1 $type.*math/big.Int ""..this  &type.*"".PrivateKey @b?@    ^BA0 
 ^2     TgclocalsÂ·7388aa65ec08dc6463e1b90d8823688a TgclocalsÂ·3280bececceccd33cb74587feedb1f9f     v/home/14/ren/source/golang/go/src/pkg/crypto/ecdsa/ecdsa.goş""".PrivateKey.Add €  æd‹   ‹	;!w1ÿ¸,   è    ëåƒìƒA ‹L$ ‹D$$‹\$4‰\$‹\$8‰\$‹\$<‰\$‹\$@‰\$‰$‹YÿÓ‹L$‹D$‰L$D‰D$Hd‹   ‹	ƒi ƒÄÃ*À  0runtime.morestack_noctxt   X8"crypto/elliptic.y P$type.*math/big.Int "crypto/elliptic.x H$type.*math/big.Int $crypto/elliptic.y2 @$type.*math/big.Int $crypto/elliptic.x2 8$type.*math/big.Int $crypto/elliptic.y1 0$type.*math/big.Int $crypto/elliptic.x1 ($type.*math/big.Int ""..this  $type."".PrivateKey 8T7 € €  P:9. 
 P0     TgclocalsÂ·d0639bedff7ffedcd56695753d30706e TgclocalsÂ·3280bececceccd33cb74587feedb1f9f     v/home/14/ren/source/golang/go/src/pkg/crypto/ecdsa/ecdsa.goş("".PrivateKey.Double à  Æd‹   ‹	;!w1ÿ¸$   è    ëåƒìƒA‹L$‹D$‹\$,‰\$‹\$0‰\$‰$‹YÿÓ‹L$‹D$‰L$4‰D$8d‹   ‹	ƒiƒÄÃ*À  0runtime.morestack_noctxt   H(
"crypto/elliptic.y @$type.*math/big.Int "crypto/elliptic.x 8$type.*math/big.Int $crypto/elliptic.y1 0$type.*math/big.Int $crypto/elliptic.x1 ($type.*math/big.Int ""..this  $type."".PrivateKey (D' p p  @*). 
 @0     TgclocalsÂ·dd6da6b6c0a8ea1724ec8c8531209fd3 TgclocalsÂ·3280bececceccd33cb74587feedb1f9f     v/home/14/ren/source/golang/go/src/pkg/crypto/ecdsa/ecdsa.goş."".PrivateKey.IsOnCurve À  ¸d‹   ‹	;!w1ÿ¸    è    ëåƒìƒA‹L$‹D$‹\$(‰\$‹\$,‰\$‰$‹YÿÓ¶\$ˆ\$0d‹   ‹	ƒiƒÄÃ*À  0runtime.morestack_noctxt   @ "".~r3 8type.bool "crypto/elliptic.y 0$type.*math/big.Int "crypto/elliptic.x ($type.*math/big.Int ""..this  $type."".PrivateKey  = ` `  @"! 
 @      TgclocalsÂ·dafc2a4ed1eccf20e0ba3ca784d254a7 TgclocalsÂ·3280bececceccd33cb74587feedb1f9f     v/home/14/ren/source/golang/go/src/pkg/crypto/ecdsa/ecdsa.goş("".PrivateKey.Params    –d‹   ‹	;!w1ÿ¸   è    ëåƒìƒA‹L$‹\$‰$‹Y ÿÓ‹\$‰\$ d‹   ‹	ƒiƒÄÃ*À  0runtime.morestack_noctxt   0"".~r1 (Btype.*crypto/elliptic.CurveParams ""..this  $type."".PrivateKey , P P  0 
 0      TgclocalsÂ·743023cec9b4b515d11a8fbfd57d92fa TgclocalsÂ·3280bececceccd33cb74587feedb1f9f     v/home/14/ren/source/golang/go/src/pkg/crypto/ecdsa/ecdsa.goş8"".PrivateKey.ScalarBaseMult à  Öd‹   ‹	;!w1ÿ¸(   è    ëåƒìƒA‹L$‹D$ ‹\$0‰\$‹\$4‰\$‹\$8‰\$‰$‹Y$ÿÓ‹L$‹D$‰L$<‰D$@d‹   ‹	ƒiƒÄÃ*À  0runtime.morestack_noctxt   P0"crypto/elliptic.y H$type.*math/big.Int "crypto/elliptic.x @$type.*math/big.Int "crypto/elliptic.k (type.[]uint8 ""..this  $type."".PrivateKey 0L/ p p  H21& 
 H(     TgclocalsÂ·38322a79137eaa1c396e575f0b7238ea TgclocalsÂ·3280bececceccd33cb74587feedb1f9f     v/home/14/ren/source/golang/go/src/pkg/crypto/ecdsa/ecdsa.goş0"".PrivateKey.ScalarMult €  öd‹   ‹	;!w1ÿ¸0   è    ëåƒì ƒA$‹L$$‹D$(‹\$8‰\$‹\$<‰\$‹\$@‰\$‹\$D‰\$‹\$H‰\$‰$‹Y(ÿÓ‹L$‹D$‰L$L‰D$Pd‹   ‹	ƒi$ƒÄ Ã*À  0runtime.morestack_noctxt   `@"crypto/elliptic.y X$type.*math/big.Int "crypto/elliptic.x P$type.*math/big.Int "crypto/elliptic.k 8type.[]uint8 $crypto/elliptic.y1 0$type.*math/big.Int $crypto/elliptic.x1 ($type.*math/big.Int ""..this  $type."".PrivateKey @\? € €  XBA& 
 X(     TgclocalsÂ·edd717db8ce7af5b5c85b5a6296ab4e5 TgclocalsÂ·3280bececceccd33cb74587feedb1f9f     v/home/14/ren/source/golang/go/src/pkg/crypto/ecdsa/ecdsa.goşTgclocalsÂ·14bf9716750c0a5ff98c507debfddc7e P  P                 Z   Z              şTgclocalsÂ·808d8a83f3ee88717356789ffec2964a P  P      »   »  »  »  »,  »,  ».  ».   şTgclocalsÂ·36f19a0b3c230d1e5b47f16afdf9b276 0  0                      şTgclocalsÂ·b7ba104b9941720a8d38022ba44cdb96 0  0      »   »  »,  ».   şTgclocalsÂ·e1ae6533a9e39048ba0735a2264ce16a                   şTgclocalsÂ·c6e1585377db5e53e487dd81250187f3           Ö  Ö   şTgclocalsÂ·80c158c520bd0c96ac6fc57c457f26fe X  X	             €  ˆ  ‚  ‚  ‚  ¢  €   şTgclocalsÂ·f5dfdf0c4f887e519cd89297c4c34bb9 X  X	      «  «…  «…  «… «… «¥ «% «% «¥  şTgclocalsÂ·a28adf168859d61f2756471f31e52ce5 p  p              €    €€ €ˆ  ˆ  Š  ‚ 
€  €       şTgclocalsÂ·ddbde40f3260d0b9c4588035a25eea26 p  p      Z
  Z
  Z
  Z
  Z
  Z
  Z
  Z
  Z
  Z
  Z
  Z
   şTgclocalsÂ·3280bececceccd33cb74587feedb1f9f           şTgclocalsÂ·3280bececceccd33cb74587feedb1f9f           ş*"".one  $type.*math/big.Int   ş,"".initdoneÂ·  type.uint8   ş,"".randFieldElementÂ·f        ˜  &"".randFieldElement   ş(runtime.makesliceÂ·f        ˜  "runtime.makeslice   şio.ReadFullÂ·f        ˜  io.ReadFull   şruntime.newÂ·f        ˜  runtime.new   ş6math/big.(*Int).SetBytesÂ·f        ˜  0math/big.(*Int).SetBytes   ş,math/big.(*Int).SubÂ·f        ˜  &math/big.(*Int).Sub   ş,math/big.(*Int).ModÂ·f        ˜  &math/big.(*Int).Mod   ş,math/big.(*Int).AddÂ·f        ˜  &math/big.(*Int).Add   ş,runtime.throwreturnÂ·f        ˜  &runtime.throwreturn   ş""".GenerateKeyÂ·f        ˜  "".GenerateKey   ş0math/big.(*Int).BytesÂ·f        ˜  *math/big.(*Int).Bytes   ş"".hashToIntÂ·f        ˜  "".hashToInt   ş2math/big.(*Int).BitLenÂ·f        ˜  ,math/big.(*Int).BitLen   ş*runtime.panicsliceÂ·f        ˜  $runtime.panicslice   ş,math/big.(*Int).RshÂ·f        ˜  &math/big.(*Int).Rsh   ş"".SignÂ·f        ˜  "".Sign   ş:math/big.(*Int).ModInverseÂ·f        ˜  4math/big.(*Int).ModInverse   ş,math/big.(*Int).MulÂ·f        ˜  &math/big.(*Int).Mul   ş"".VerifyÂ·f        ˜  "".Verify   ş,math/big.(*Int).CmpÂ·f        ˜  &math/big.(*Int).Cmp   ş"".initÂ·f        ˜  "".init   ş(runtime.throwinitÂ·f        ˜  "runtime.throwinit   ş math/big.initÂ·f        ˜  math/big.init   şio.initÂ·f        ˜  io.init   ş.crypto/elliptic.initÂ·f        ˜  (crypto/elliptic.init   ş6math/big.(*Int).SetInt64Â·f        ˜  0math/big.(*Int).SetInt64   ştype..gc.uint8           ş type..gc.[]uint8 (  (   
               ˜  type..gc.uint8   ş&go.string."[]uint8"            []uint8  ˜ &go.string."[]uint8"   ştype.[]uint8 P  P   ß~.8                             ˜   runtime.algarray    ˜   type..gc.[]uint8   (˜  &go.string."[]uint8"   8˜  *go.weak.type.*[]uint8   @˜  "runtime.zerovalue   H˜  type.uint8   ş6go.typelink.[]uint8/[]uint8        ˜  type.[]uint8   şTgclocalsÂ·3280bececceccd33cb74587feedb1f9f           şTgclocalsÂ·c34189e3b824b0bbe5cf2ca4e567d435         &    şTgclocalsÂ·7b2d1dc8e692ba633cb2c876407e20f2      
        şTgclocalsÂ·42ea2d2340f90cf3f379f66fe4b2d382         ¦    ş,type..alg."".PublicKey                      ˜  .type..hash."".PublicKey   ˜  *type..eq."".PublicKey   ˜   runtime.memprint   ˜  $runtime.memcopy128   ş,type..gc.math/big.Word           ş*type..gc.math/big.Int (  (   
              ˜  ,type..gc.math/big.Word   ş*type..gc."".PublicKey P  P   	                               (˜  *type..gc.math/big.Int   @˜  *type..gc.math/big.Int   ş,type..gc.*"".PublicKey (  (                  ˜  *type..gc."".PublicKey   ş8go.string."*ecdsa.PublicKey" 8  2       *ecdsa.PublicKey  ˜ 8go.string."*ecdsa.PublicKey"   şTgclocalsÂ·3280bececceccd33cb74587feedb1f9f           şTgclocalsÂ·be52d99fd4fc187ec6a3cd1eab5661d9         ª   şTgclocalsÂ·3280bececceccd33cb74587feedb1f9f           şTgclocalsÂ·6e5d4a330d25067342b1b461a5d19024      
   *    şTgclocalsÂ·3280bececceccd33cb74587feedb1f9f           şTgclocalsÂ·8d11a518189555fd7f3bac3cc6ad264c         *    şTgclocalsÂ·3280bececceccd33cb74587feedb1f9f           şTgclocalsÂ·06cab038d51064a089bda21fa03e00f7             şTgclocalsÂ·3280bececceccd33cb74587feedb1f9f           şTgclocalsÂ·f7455b879dcc824579f14b4bd8303508         Z    şTgclocalsÂ·3280bececceccd33cb74587feedb1f9f           şTgclocalsÂ·7388aa65ec08dc6463e1b90d8823688a         ª   şîtype..gc.func(*"".PublicKey, *math/big.Int, *math/big.Int, *math/big.Int, *math/big.Int) (*math/big.Int, *math/big.Int)                    ş¾go.string."func(*ecdsa.PublicKey, *big.Int, *big.Int, *big.Int, *big.Int) (*big.Int, *big.Int)" ¸  ¸    S   func(*ecdsa.PublicKey, *big.Int, *big.Int, *big.Int, *big.Int) (*big.Int, *big.Int)  ˜ ¾go.string."func(*ecdsa.PublicKey, *big.Int, *big.Int, *big.Int, *big.Int) (*big.Int, *big.Int)"   şætype.func(*"".PublicKey, *math/big.Int, *math/big.Int, *math/big.Int, *math/big.Int) (*math/big.Int, *math/big.Int) ¸  ¸   ²% •                                                                             ˜à  runtime.algarray    ˜  îtype..gc.func(*"".PublicKey, *math/big.Int, *math/big.Int, *math/big.Int, *math/big.Int) (*math/big.Int, *math/big.Int)   (˜  ¾go.string."func(*ecdsa.PublicKey, *big.Int, *big.Int, *big.Int, *big.Int) (*big.Int, *big.Int)"   8˜  øgo.weak.type.*func(*"".PublicKey, *math/big.Int, *math/big.Int, *math/big.Int, *math/big.Int) (*math/big.Int, *math/big.Int)   @˜  "runtime.zerovalue   P˜€ ætype.func(*"".PublicKey, *math/big.Int, *math/big.Int, *math/big.Int, *math/big.Int) (*math/big.Int, *math/big.Int)   h˜¨ ætype.func(*"".PublicKey, *math/big.Int, *math/big.Int, *math/big.Int, *math/big.Int) (*math/big.Int, *math/big.Int)   €˜  $type.*"".PublicKey   ˆ˜  $type.*math/big.Int   ˜  $type.*math/big.Int   ˜˜  $type.*math/big.Int    ˜  $type.*math/big.Int   ¨˜  $type.*math/big.Int   °˜  $type.*math/big.Int   ş²type..gc.func(*"".PublicKey, *math/big.Int, *math/big.Int) (*math/big.Int, *math/big.Int)                    ş–go.string."func(*ecdsa.PublicKey, *big.Int, *big.Int) (*big.Int, *big.Int)"       ?   func(*ecdsa.PublicKey, *big.Int, *big.Int) (*big.Int, *big.Int)  ˜ –go.string."func(*ecdsa.PublicKey, *big.Int, *big.Int) (*big.Int, *big.Int)"   şªtype.func(*"".PublicKey, *math/big.Int, *math/big.Int) (*math/big.Int, *math/big.Int) ¨  ¨   ö&‡?                                                                     ˜à  runtime.algarray    ˜  ²type..gc.func(*"".PublicKey, *math/big.Int, *math/big.Int) (*math/big.Int, *math/big.Int)   (˜  –go.string."func(*ecdsa.PublicKey, *big.Int, *big.Int) (*big.Int, *big.Int)"   8˜  ¼go.weak.type.*func(*"".PublicKey, *math/big.Int, *math/big.Int) (*math/big.Int, *math/big.Int)   @˜  "runtime.zerovalue   P˜€ ªtype.func(*"".PublicKey, *math/big.Int, *math/big.Int) (*math/big.Int, *math/big.Int)   h˜˜ ªtype.func(*"".PublicKey, *math/big.Int, *math/big.Int) (*math/big.Int, *math/big.Int)   €˜  $type.*"".PublicKey   ˆ˜  $type.*math/big.Int   ˜  $type.*math/big.Int   ˜˜  $type.*math/big.Int    ˜  $type.*math/big.Int   ş~type..gc.func(*"".PublicKey, *math/big.Int, *math/big.Int) bool                    şvgo.string."func(*ecdsa.PublicKey, *big.Int, *big.Int) bool" p  p    /   func(*ecdsa.PublicKey, *big.Int, *big.Int) bool  ˜ vgo.string."func(*ecdsa.PublicKey, *big.Int, *big.Int) bool"   şvtype.func(*"".PublicKey, *math/big.Int, *math/big.Int) bool        ›²N¢                                                                 ˜à  runtime.algarray    ˜  ~type..gc.func(*"".PublicKey, *math/big.Int, *math/big.Int) bool   (˜  vgo.string."func(*ecdsa.PublicKey, *big.Int, *big.Int) bool"   8˜  ˆgo.weak.type.*func(*"".PublicKey, *math/big.Int, *math/big.Int) bool   @˜  "runtime.zerovalue   P˜€ vtype.func(*"".PublicKey, *math/big.Int, *math/big.Int) bool   h˜˜ vtype.func(*"".PublicKey, *math/big.Int, *math/big.Int) bool   €˜  $type.*"".PublicKey   ˆ˜  $type.*math/big.Int   ˜  $type.*math/big.Int   ˜˜  type.bool   şrtype..gc.func(*"".PublicKey) *crypto/elliptic.CurveParams                    şpgo.string."func(*ecdsa.PublicKey) *elliptic.CurveParams" p  j    ,   func(*ecdsa.PublicKey) *elliptic.CurveParams  ˜ pgo.string."func(*ecdsa.PublicKey) *elliptic.CurveParams"   şjtype.func(*"".PublicKey) *crypto/elliptic.CurveParams      Zmdš                                                         ˜à  runtime.algarray    ˜  rtype..gc.func(*"".PublicKey) *crypto/elliptic.CurveParams   (˜  pgo.string."func(*ecdsa.PublicKey) *elliptic.CurveParams"   8˜  |go.weak.type.*func(*"".PublicKey) *crypto/elliptic.CurveParams   @˜  "runtime.zerovalue   P˜€ jtype.func(*"".PublicKey) *crypto/elliptic.CurveParams   h˜ˆ jtype.func(*"".PublicKey) *crypto/elliptic.CurveParams   €˜  $type.*"".PublicKey   ˆ˜  Btype.*crypto/elliptic.CurveParams   şˆtype..gc.func(*"".PublicKey, []uint8) (*math/big.Int, *math/big.Int)                    ş€go.string."func(*ecdsa.PublicKey, []uint8) (*big.Int, *big.Int)" €  z    4   func(*ecdsa.PublicKey, []uint8) (*big.Int, *big.Int)  ˜ €go.string."func(*ecdsa.PublicKey, []uint8) (*big.Int, *big.Int)"   ş€type.func(*"".PublicKey, []uint8) (*math/big.Int, *math/big.Int)        3nÄ7                                                                 ˜à  runtime.algarray    ˜  ˆtype..gc.func(*"".PublicKey, []uint8) (*math/big.Int, *math/big.Int)   (˜  €go.string."func(*ecdsa.PublicKey, []uint8) (*big.Int, *big.Int)"   8˜  ’go.weak.type.*func(*"".PublicKey, []uint8) (*math/big.Int, *math/big.Int)   @˜  "runtime.zerovalue   P˜€ €type.func(*"".PublicKey, []uint8) (*math/big.Int, *math/big.Int)   h˜ €type.func(*"".PublicKey, []uint8) (*math/big.Int, *math/big.Int)   €˜  $type.*"".PublicKey   ˆ˜  type.[]uint8   ˜  $type.*math/big.Int   ˜˜  $type.*math/big.Int   şÄtype..gc.func(*"".PublicKey, *math/big.Int, *math/big.Int, []uint8) (*math/big.Int, *math/big.Int)                    ş¨go.string."func(*ecdsa.PublicKey, *big.Int, *big.Int, []uint8) (*big.Int, *big.Int)" ¨  ¢    H   func(*ecdsa.PublicKey, *big.Int, *big.Int, []uint8) (*big.Int, *big.Int)  ˜ ¨go.string."func(*ecdsa.PublicKey, *big.Int, *big.Int, []uint8) (*big.Int, *big.Int)"   ş¼type.func(*"".PublicKey, *math/big.Int, *math/big.Int, []uint8) (*math/big.Int, *math/big.Int) °  °   fy<                                                                         ˜à  runtime.algarray    ˜  Ätype..gc.func(*"".PublicKey, *math/big.Int, *math/big.Int, []uint8) (*math/big.Int, *math/big.Int)   (˜  ¨go.string."func(*ecdsa.PublicKey, *big.Int, *big.Int, []uint8) (*big.Int, *big.Int)"   8˜  Îgo.weak.type.*func(*"".PublicKey, *math/big.Int, *math/big.Int, []uint8) (*math/big.Int, *math/big.Int)   @˜  "runtime.zerovalue   P˜€ ¼type.func(*"".PublicKey, *math/big.Int, *math/big.Int, []uint8) (*math/big.Int, *math/big.Int)   h˜  ¼type.func(*"".PublicKey, *math/big.Int, *math/big.Int, []uint8) (*math/big.Int, *math/big.Int)   €˜  $type.*"".PublicKey   ˆ˜  $type.*math/big.Int   ˜  $type.*math/big.Int   ˜˜  type.[]uint8    ˜  $type.*math/big.Int   ¨˜  $type.*math/big.Int   şgo.string."Add"          Add  ˜ go.string."Add"   şĞtype..gc.func(*math/big.Int, *math/big.Int, *math/big.Int, *math/big.Int) (*math/big.Int, *math/big.Int)                    şšgo.string."func(*big.Int, *big.Int, *big.Int, *big.Int) (*big.Int, *big.Int)" ˜  ”    A   func(*big.Int, *big.Int, *big.Int, *big.Int) (*big.Int, *big.Int)  ˜ šgo.string."func(*big.Int, *big.Int, *big.Int, *big.Int) (*big.Int, *big.Int)"   şÈtype.func(*math/big.Int, *math/big.Int, *math/big.Int, *math/big.Int) (*math/big.Int, *math/big.Int) °  °   ğ\áõ                                                                         ˜à  runtime.algarray    ˜  Ğtype..gc.func(*math/big.Int, *math/big.Int, *math/big.Int, *math/big.Int) (*math/big.Int, *math/big.Int)   (˜  šgo.string."func(*big.Int, *big.Int, *big.Int, *big.Int) (*big.Int, *big.Int)"   8˜  Úgo.weak.type.*func(*math/big.Int, *math/big.Int, *math/big.Int, *math/big.Int) (*math/big.Int, *math/big.Int)   @˜  "runtime.zerovalue   P˜€ Ètype.func(*math/big.Int, *math/big.Int, *math/big.Int, *math/big.Int) (*math/big.Int, *math/big.Int)   h˜  Ètype.func(*math/big.Int, *math/big.Int, *math/big.Int, *math/big.Int) (*math/big.Int, *math/big.Int)   €˜  $type.*math/big.Int   ˆ˜  $type.*math/big.Int   ˜  $type.*math/big.Int   ˜˜  $type.*math/big.Int    ˜  $type.*math/big.Int   ¨˜  $type.*math/big.Int   ş$go.string."Double"           Double  ˜ $go.string."Double"   ş”type..gc.func(*math/big.Int, *math/big.Int) (*math/big.Int, *math/big.Int)                    şrgo.string."func(*big.Int, *big.Int) (*big.Int, *big.Int)" p  l    -   func(*big.Int, *big.Int) (*big.Int, *big.Int)  ˜ rgo.string."func(*big.Int, *big.Int) (*big.Int, *big.Int)"   şŒtype.func(*math/big.Int, *math/big.Int) (*math/big.Int, *math/big.Int)        3`1
                                                                 ˜à  runtime.algarray    ˜  ”type..gc.func(*math/big.Int, *math/big.Int) (*math/big.Int, *math/big.Int)   (˜  rgo.string."func(*big.Int, *big.Int) (*big.Int, *big.Int)"   8˜  go.weak.type.*func(*math/big.Int, *math/big.Int) (*math/big.Int, *math/big.Int)   @˜  "runtime.zerovalue   P˜€ Œtype.func(*math/big.Int, *math/big.Int) (*math/big.Int, *math/big.Int)   h˜ Œtype.func(*math/big.Int, *math/big.Int) (*math/big.Int, *math/big.Int)   €˜  $type.*math/big.Int   ˆ˜  $type.*math/big.Int   ˜  $type.*math/big.Int   ˜˜  $type.*math/big.Int   ş*go.string."IsOnCurve" (  $    	   IsOnCurve  ˜ *go.string."IsOnCurve"   ş`type..gc.func(*math/big.Int, *math/big.Int) bool                    şRgo.string."func(*big.Int, *big.Int) bool" P  L       func(*big.Int, *big.Int) bool  ˜ Rgo.string."func(*big.Int, *big.Int) bool"   şXtype.func(*math/big.Int, *math/big.Int) bool ˜  ˜   À§                                                             ˜à  runtime.algarray    ˜  `type..gc.func(*math/big.Int, *math/big.Int) bool   (˜  Rgo.string."func(*big.Int, *big.Int) bool"   8˜  jgo.weak.type.*func(*math/big.Int, *math/big.Int) bool   @˜  "runtime.zerovalue   P˜€ Xtype.func(*math/big.Int, *math/big.Int) bool   h˜ Xtype.func(*math/big.Int, *math/big.Int) bool   €˜  $type.*math/big.Int   ˆ˜  $type.*math/big.Int   ˜  type.bool   ş$go.string."Params"           Params  ˜ $go.string."Params"   şXtype..gc.func() *crypto/elliptic.CurveParams                    şPgo.string."func() *elliptic.CurveParams" P  J       func() *elliptic.CurveParams  ˜ Pgo.string."func() *elliptic.CurveParams"   şPtype.func() *crypto/elliptic.CurveParams ˆ  ˆ   ˆ¨"å                                                       ˜à  runtime.algarray    ˜  Xtype..gc.func() *crypto/elliptic.CurveParams   (˜  Pgo.string."func() *elliptic.CurveParams"   8˜  bgo.weak.type.*func() *crypto/elliptic.CurveParams   @˜  "runtime.zerovalue   P˜€ Ptype.func() *crypto/elliptic.CurveParams   h˜€ Ptype.func() *crypto/elliptic.CurveParams   €˜  Btype.*crypto/elliptic.CurveParams   ş4go.string."ScalarBaseMult" 0  .       ScalarBaseMult  ˜ 4go.string."ScalarBaseMult"   şjtype..gc.func([]uint8) (*math/big.Int, *math/big.Int)                    ş\go.string."func([]uint8) (*big.Int, *big.Int)" X  V    "   func([]uint8) (*big.Int, *big.Int)  ˜ \go.string."func([]uint8) (*big.Int, *big.Int)"   şbtype.func([]uint8) (*math/big.Int, *math/big.Int) ˜  ˜   €Ÿ.l                                                             ˜à  runtime.algarray    ˜  jtype..gc.func([]uint8) (*math/big.Int, *math/big.Int)   (˜  \go.string."func([]uint8) (*big.Int, *big.Int)"   8˜  tgo.weak.type.*func([]uint8) (*math/big.Int, *math/big.Int)   @˜  "runtime.zerovalue   P˜€ btype.func([]uint8) (*math/big.Int, *math/big.Int)   h˜ˆ btype.func([]uint8) (*math/big.Int, *math/big.Int)   €˜  type.[]uint8   ˆ˜  $type.*math/big.Int   ˜  $type.*math/big.Int   ş,go.string."ScalarMult" (  &    
   ScalarMult  ˜ ,go.string."ScalarMult"   ş¦type..gc.func(*math/big.Int, *math/big.Int, []uint8) (*math/big.Int, *math/big.Int)                    ş„go.string."func(*big.Int, *big.Int, []uint8) (*big.Int, *big.Int)" €  ~    6   func(*big.Int, *big.Int, []uint8) (*big.Int, *big.Int)  ˜ „go.string."func(*big.Int, *big.Int, []uint8) (*big.Int, *big.Int)"   ştype.func(*math/big.Int, *math/big.Int, []uint8) (*math/big.Int, *math/big.Int) ¨  ¨   ašÙÂ                                                                     ˜à  runtime.algarray    ˜  ¦type..gc.func(*math/big.Int, *math/big.Int, []uint8) (*math/big.Int, *math/big.Int)   (˜  „go.string."func(*big.Int, *big.Int, []uint8) (*big.Int, *big.Int)"   8˜  °go.weak.type.*func(*math/big.Int, *math/big.Int, []uint8) (*math/big.Int, *math/big.Int)   @˜  "runtime.zerovalue   P˜€ type.func(*math/big.Int, *math/big.Int, []uint8) (*math/big.Int, *math/big.Int)   h˜˜ type.func(*math/big.Int, *math/big.Int, []uint8) (*math/big.Int, *math/big.Int)   €˜  $type.*math/big.Int   ˆ˜  $type.*math/big.Int   ˜  type.[]uint8   ˜˜  $type.*math/big.Int    ˜  $type.*math/big.Int   ş$type.*"".PublicKey  ˜  ˜   €Ğ/                                                                                                                                                                                               L˜€  runtime.algarray    ˜  ,type..gc.*"".PublicKey   (˜  8go.string."*ecdsa.PublicKey"   8˜  6go.weak.type.**"".PublicKey   @˜  "runtime.zerovalue   H˜  "type."".PublicKey   0˜P $type.*"".PublicKey   `˜x $type.*"".PublicKey   x˜  go.string."Add"   ˆ˜  Ètype.func(*math/big.Int, *math/big.Int, *math/big.Int, *math/big.Int) (*math/big.Int, *math/big.Int)   ˜  ætype.func(*"".PublicKey, *math/big.Int, *math/big.Int, *math/big.Int, *math/big.Int) (*math/big.Int, *math/big.Int)   ˜˜  &"".(*PublicKey).Add    ˜  &"".(*PublicKey).Add   ¨˜  $go.string."Double"   ¸˜  Œtype.func(*math/big.Int, *math/big.Int) (*math/big.Int, *math/big.Int)   À˜  ªtype.func(*"".PublicKey, *math/big.Int, *math/big.Int) (*math/big.Int, *math/big.Int)   È˜  ,"".(*PublicKey).Double   Ğ˜  ,"".(*PublicKey).Double   Ø˜  *go.string."IsOnCurve"   è˜  Xtype.func(*math/big.Int, *math/big.Int) bool   ğ˜  vtype.func(*"".PublicKey, *math/big.Int, *math/big.Int) bool   ø˜  2"".(*PublicKey).IsOnCurve   €˜  2"".(*PublicKey).IsOnCurve   ˆ˜  $go.string."Params"   ˜˜  Ptype.func() *crypto/elliptic.CurveParams    ˜  jtype.func(*"".PublicKey) *crypto/elliptic.CurveParams   ¨˜  ,"".(*PublicKey).Params   °˜  ,"".(*PublicKey).Params   ¸˜  4go.string."ScalarBaseMult"   È˜  btype.func([]uint8) (*math/big.Int, *math/big.Int)   Ğ˜  €type.func(*"".PublicKey, []uint8) (*math/big.Int, *math/big.Int)   Ø˜  <"".(*PublicKey).ScalarBaseMult   à˜  <"".(*PublicKey).ScalarBaseMult   è˜  ,go.string."ScalarMult"   ø˜  type.func(*math/big.Int, *math/big.Int, []uint8) (*math/big.Int, *math/big.Int)   €˜  ¼type.func(*"".PublicKey, *math/big.Int, *math/big.Int, []uint8) (*math/big.Int, *math/big.Int)   ˆ˜  4"".(*PublicKey).ScalarMult   ˜  4"".(*PublicKey).ScalarMult   ş6go.string."ecdsa.PublicKey" 0  0       ecdsa.PublicKey  ˜ 6go.string."ecdsa.PublicKey"   şgo.string."X"          X  ˜ go.string."X"   şgo.string."Y"          Y  ˜ go.string."Y"   şTgclocalsÂ·3280bececceccd33cb74587feedb1f9f           şTgclocalsÂ·78ad52f947c0f9e54dd0fb4377b33085         «ª   şTgclocalsÂ·3280bececceccd33cb74587feedb1f9f           şTgclocalsÂ·2c26e9496b1c078fc62b3f021ed30e75         «
   şTgclocalsÂ·3280bececceccd33cb74587feedb1f9f           şTgclocalsÂ·533e41f03c38242213357bdf241c642f         «
   şTgclocalsÂ·3280bececceccd33cb74587feedb1f9f           şTgclocalsÂ·564befda8e2e8cc7f35f6bc1d3c5e0a6      
   «    şTgclocalsÂ·3280bececceccd33cb74587feedb1f9f           şTgclocalsÂ·47970fecb85752c2006cb09cd4115497         «   şTgclocalsÂ·3280bececceccd33cb74587feedb1f9f           şTgclocalsÂ·061982756bec02206530e2020a77f696         «j  şìtype..gc.func("".PublicKey, *math/big.Int, *math/big.Int, *math/big.Int, *math/big.Int) (*math/big.Int, *math/big.Int)                    ş¼go.string."func(ecdsa.PublicKey, *big.Int, *big.Int, *big.Int, *big.Int) (*big.Int, *big.Int)" ¸  ¶    R   func(ecdsa.PublicKey, *big.Int, *big.Int, *big.Int, *big.Int) (*big.Int, *big.Int)  ˜ ¼go.string."func(ecdsa.PublicKey, *big.Int, *big.Int, *big.Int, *big.Int) (*big.Int, *big.Int)"   şätype.func("".PublicKey, *math/big.Int, *math/big.Int, *math/big.Int, *math/big.Int) (*math/big.Int, *math/big.Int) ¸  ¸   ôgİz                                                                             ˜à  runtime.algarray    ˜  ìtype..gc.func("".PublicKey, *math/big.Int, *math/big.Int, *math/big.Int, *math/big.Int) (*math/big.Int, *math/big.Int)   (˜  ¼go.string."func(ecdsa.PublicKey, *big.Int, *big.Int, *big.Int, *big.Int) (*big.Int, *big.Int)"   8˜  ögo.weak.type.*func("".PublicKey, *math/big.Int, *math/big.Int, *math/big.Int, *math/big.Int) (*math/big.Int, *math/big.Int)   @˜  "runtime.zerovalue   P˜€ ätype.func("".PublicKey, *math/big.Int, *math/big.Int, *math/big.Int, *math/big.Int) (*math/big.Int, *math/big.Int)   h˜¨ ätype.func("".PublicKey, *math/big.Int, *math/big.Int, *math/big.Int, *math/big.Int) (*math/big.Int, *math/big.Int)   €˜  "type."".PublicKey   ˆ˜  $type.*math/big.Int   ˜  $type.*math/big.Int   ˜˜  $type.*math/big.Int    ˜  $type.*math/big.Int   ¨˜  $type.*math/big.Int   °˜  $type.*math/big.Int   ş°type..gc.func("".PublicKey, *math/big.Int, *math/big.Int) (*math/big.Int, *math/big.Int)                    ş”go.string."func(ecdsa.PublicKey, *big.Int, *big.Int) (*big.Int, *big.Int)"       >   func(ecdsa.PublicKey, *big.Int, *big.Int) (*big.Int, *big.Int)  ˜ ”go.string."func(ecdsa.PublicKey, *big.Int, *big.Int) (*big.Int, *big.Int)"   ş¨type.func("".PublicKey, *math/big.Int, *math/big.Int) (*math/big.Int, *math/big.Int) ¨  ¨   º|¶ù                                                                     ˜à  runtime.algarray    ˜  °type..gc.func("".PublicKey, *math/big.Int, *math/big.Int) (*math/big.Int, *math/big.Int)   (˜  ”go.string."func(ecdsa.PublicKey, *big.Int, *big.Int) (*big.Int, *big.Int)"   8˜  ºgo.weak.type.*func("".PublicKey, *math/big.Int, *math/big.Int) (*math/big.Int, *math/big.Int)   @˜  "runtime.zerovalue   P˜€ ¨type.func("".PublicKey, *math/big.Int, *math/big.Int) (*math/big.Int, *math/big.Int)   h˜˜ ¨type.func("".PublicKey, *math/big.Int, *math/big.Int) (*math/big.Int, *math/big.Int)   €˜  "type."".PublicKey   ˆ˜  $type.*math/big.Int   ˜  $type.*math/big.Int   ˜˜  $type.*math/big.Int    ˜  $type.*math/big.Int   ş|type..gc.func("".PublicKey, *math/big.Int, *math/big.Int) bool                    ştgo.string."func(ecdsa.PublicKey, *big.Int, *big.Int) bool" p  n    .   func(ecdsa.PublicKey, *big.Int, *big.Int) bool  ˜ tgo.string."func(ecdsa.PublicKey, *big.Int, *big.Int) bool"   şttype.func("".PublicKey, *math/big.Int, *math/big.Int) bool        Å                                                                 ˜à  runtime.algarray    ˜  |type..gc.func("".PublicKey, *math/big.Int, *math/big.Int) bool   (˜  tgo.string."func(ecdsa.PublicKey, *big.Int, *big.Int) bool"   8˜  †go.weak.type.*func("".PublicKey, *math/big.Int, *math/big.Int) bool   @˜  "runtime.zerovalue   P˜€ ttype.func("".PublicKey, *math/big.Int, *math/big.Int) bool   h˜˜ ttype.func("".PublicKey, *math/big.Int, *math/big.Int) bool   €˜  "type."".PublicKey   ˆ˜  $type.*math/big.Int   ˜  $type.*math/big.Int   ˜˜  type.bool   şptype..gc.func("".PublicKey) *crypto/elliptic.CurveParams                    şngo.string."func(ecdsa.PublicKey) *elliptic.CurveParams" h  h    +   func(ecdsa.PublicKey) *elliptic.CurveParams  ˜ ngo.string."func(ecdsa.PublicKey) *elliptic.CurveParams"   şhtype.func("".PublicKey) *crypto/elliptic.CurveParams      ¶ñÓ±                                                         ˜à  runtime.algarray    ˜  ptype..gc.func("".PublicKey) *crypto/elliptic.CurveParams   (˜  ngo.string."func(ecdsa.PublicKey) *elliptic.CurveParams"   8˜  zgo.weak.type.*func("".PublicKey) *crypto/elliptic.CurveParams   @˜  "runtime.zerovalue   P˜€ htype.func("".PublicKey) *crypto/elliptic.CurveParams   h˜ˆ htype.func("".PublicKey) *crypto/elliptic.CurveParams   €˜  "type."".PublicKey   ˆ˜  Btype.*crypto/elliptic.CurveParams   ş†type..gc.func("".PublicKey, []uint8) (*math/big.Int, *math/big.Int)                    ş~go.string."func(ecdsa.PublicKey, []uint8) (*big.Int, *big.Int)" x  x    3   func(ecdsa.PublicKey, []uint8) (*big.Int, *big.Int)  ˜ ~go.string."func(ecdsa.PublicKey, []uint8) (*big.Int, *big.Int)"   ş~type.func("".PublicKey, []uint8) (*math/big.Int, *math/big.Int)        g«¿                                                                 ˜à  runtime.algarray    ˜  †type..gc.func("".PublicKey, []uint8) (*math/big.Int, *math/big.Int)   (˜  ~go.string."func(ecdsa.PublicKey, []uint8) (*big.Int, *big.Int)"   8˜  go.weak.type.*func("".PublicKey, []uint8) (*math/big.Int, *math/big.Int)   @˜  "runtime.zerovalue   P˜€ ~type.func("".PublicKey, []uint8) (*math/big.Int, *math/big.Int)   h˜ ~type.func("".PublicKey, []uint8) (*math/big.Int, *math/big.Int)   €˜  "type."".PublicKey   ˆ˜  type.[]uint8   ˜  $type.*math/big.Int   ˜˜  $type.*math/big.Int   şÂtype..gc.func("".PublicKey, *math/big.Int, *math/big.Int, []uint8) (*math/big.Int, *math/big.Int)                    ş¦go.string."func(ecdsa.PublicKey, *big.Int, *big.Int, []uint8) (*big.Int, *big.Int)"         G   func(ecdsa.PublicKey, *big.Int, *big.Int, []uint8) (*big.Int, *big.Int)  ˜ ¦go.string."func(ecdsa.PublicKey, *big.Int, *big.Int, []uint8) (*big.Int, *big.Int)"   şºtype.func("".PublicKey, *math/big.Int, *math/big.Int, []uint8) (*math/big.Int, *math/big.Int) °  °    “Rg                                                                         ˜à  runtime.algarray    ˜  Âtype..gc.func("".PublicKey, *math/big.Int, *math/big.Int, []uint8) (*math/big.Int, *math/big.Int)   (˜  ¦go.string."func(ecdsa.PublicKey, *big.Int, *big.Int, []uint8) (*big.Int, *big.Int)"   8˜  Ìgo.weak.type.*func("".PublicKey, *math/big.Int, *math/big.Int, []uint8) (*math/big.Int, *math/big.Int)   @˜  "runtime.zerovalue   P˜€ ºtype.func("".PublicKey, *math/big.Int, *math/big.Int, []uint8) (*math/big.Int, *math/big.Int)   h˜  ºtype.func("".PublicKey, *math/big.Int, *math/big.Int, []uint8) (*math/big.Int, *math/big.Int)   €˜  "type."".PublicKey   ˆ˜  $type.*math/big.Int   ˜  $type.*math/big.Int   ˜˜  type.[]uint8    ˜  $type.*math/big.Int   ¨˜  $type.*math/big.Int   ş*go.string."PublicKey" (  $    	   PublicKey  ˜ *go.string."PublicKey"   ş"type."".PublicKey         ™ÉZN                                                                                                                                                                                                                                                               Z˜  ,type..alg."".PublicKey    ˜  *type..gc."".PublicKey   (˜  6go.string."ecdsa.PublicKey"   8˜  $type.*"".PublicKey   @˜  "runtime.zerovalue   H˜` "type."".PublicKey   p˜  4type.crypto/elliptic.Curve   ˆ˜  go.string."X"   ˜˜  $type.*math/big.Int   °˜  go.string."Y"   À˜  $type.*math/big.Int   0˜Ø "type."".PublicKey   Ø˜  *go.string."PublicKey"   à˜  "go.importpath."".   è˜€ "type."".PublicKey   €˜  go.string."Add"   ˜  Ètype.func(*math/big.Int, *math/big.Int, *math/big.Int, *math/big.Int) (*math/big.Int, *math/big.Int)   ˜˜  ätype.func("".PublicKey, *math/big.Int, *math/big.Int, *math/big.Int, *math/big.Int) (*math/big.Int, *math/big.Int)    ˜  &"".(*PublicKey).Add   ¨˜   "".PublicKey.Add   °˜  $go.string."Double"   À˜  Œtype.func(*math/big.Int, *math/big.Int) (*math/big.Int, *math/big.Int)   È˜  ¨type.func("".PublicKey, *math/big.Int, *math/big.Int) (*math/big.Int, *math/big.Int)   Ğ˜  ,"".(*PublicKey).Double   Ø˜  &"".PublicKey.Double   à˜  *go.string."IsOnCurve"   ğ˜  Xtype.func(*math/big.Int, *math/big.Int) bool   ø˜  ttype.func("".PublicKey, *math/big.Int, *math/big.Int) bool   €˜  2"".(*PublicKey).IsOnCurve   ˆ˜  ,"".PublicKey.IsOnCurve   ˜  $go.string."Params"    ˜  Ptype.func() *crypto/elliptic.CurveParams   ¨˜  htype.func("".PublicKey) *crypto/elliptic.CurveParams   °˜  ,"".(*PublicKey).Params   ¸˜  &"".PublicKey.Params   À˜  4go.string."ScalarBaseMult"   Ğ˜  btype.func([]uint8) (*math/big.Int, *math/big.Int)   Ø˜  ~type.func("".PublicKey, []uint8) (*math/big.Int, *math/big.Int)   à˜  <"".(*PublicKey).ScalarBaseMult   è˜  6"".PublicKey.ScalarBaseMult   ğ˜  ,go.string."ScalarMult"   €˜  type.func(*math/big.Int, *math/big.Int, []uint8) (*math/big.Int, *math/big.Int)   ˆ˜  ºtype.func("".PublicKey, *math/big.Int, *math/big.Int, []uint8) (*math/big.Int, *math/big.Int)   ˜  4"".(*PublicKey).ScalarMult   ˜˜  ."".PublicKey.ScalarMult   şTgclocalsÂ·3280bececceccd33cb74587feedb1f9f           şTgclocalsÂ·c34189e3b824b0bbe5cf2ca4e567d435         &    şTgclocalsÂ·1c5b1c90a4c2549bb9ca6a7854f35d0e                    şTgclocalsÂ·e883500196cbb0efce3121f314db1635           ¦   ¦    ş.type..alg."".PrivateKey                      ˜  0type..hash."".PrivateKey   ˜  ,type..eq."".PrivateKey   ˜   runtime.memprint   ˜  runtime.memcopy   ş,type..gc."".PrivateKey h  h   	                                         (˜  *type..gc.math/big.Int   @˜  *type..gc.math/big.Int   X˜  *type..gc.math/big.Int   ş.type..gc.*"".PrivateKey (  (                  ˜  ,type..gc."".PrivateKey   ş:go.string."*ecdsa.PrivateKey" 8  4       *ecdsa.PrivateKey  ˜ :go.string."*ecdsa.PrivateKey"   şTgclocalsÂ·3280bececceccd33cb74587feedb1f9f           şTgclocalsÂ·be52d99fd4fc187ec6a3cd1eab5661d9         ª   şTgclocalsÂ·3280bececceccd33cb74587feedb1f9f           şTgclocalsÂ·6e5d4a330d25067342b1b461a5d19024      
   *    şTgclocalsÂ·3280bececceccd33cb74587feedb1f9f           şTgclocalsÂ·8d11a518189555fd7f3bac3cc6ad264c         *    şTgclocalsÂ·3280bececceccd33cb74587feedb1f9f           şTgclocalsÂ·06cab038d51064a089bda21fa03e00f7             şTgclocalsÂ·3280bececceccd33cb74587feedb1f9f           şTgclocalsÂ·f7455b879dcc824579f14b4bd8303508         Z    şTgclocalsÂ·3280bececceccd33cb74587feedb1f9f           şTgclocalsÂ·7388aa65ec08dc6463e1b90d8823688a         ª   şğtype..gc.func(*"".PrivateKey, *math/big.Int, *math/big.Int, *math/big.Int, *math/big.Int) (*math/big.Int, *math/big.Int)                    şÀgo.string."func(*ecdsa.PrivateKey, *big.Int, *big.Int, *big.Int, *big.Int) (*big.Int, *big.Int)" À  º    T   func(*ecdsa.PrivateKey, *big.Int, *big.Int, *big.Int, *big.Int) (*big.Int, *big.Int)  ˜ Àgo.string."func(*ecdsa.PrivateKey, *big.Int, *big.Int, *big.Int, *big.Int) (*big.Int, *big.Int)"   şètype.func(*"".PrivateKey, *math/big.Int, *math/big.Int, *math/big.Int, *math/big.Int) (*math/big.Int, *math/big.Int) ¸  ¸   w©Kı                                                                             ˜à  runtime.algarray    ˜  ğtype..gc.func(*"".PrivateKey, *math/big.Int, *math/big.Int, *math/big.Int, *math/big.Int) (*math/big.Int, *math/big.Int)   (˜  Àgo.string."func(*ecdsa.PrivateKey, *big.Int, *big.Int, *big.Int, *big.Int) (*big.Int, *big.Int)"   8˜  úgo.weak.type.*func(*"".PrivateKey, *math/big.Int, *math/big.Int, *math/big.Int, *math/big.Int) (*math/big.Int, *math/big.Int)   @˜  "runtime.zerovalue   P˜€ ètype.func(*"".PrivateKey, *math/big.Int, *math/big.Int, *math/big.Int, *math/big.Int) (*math/big.Int, *math/big.Int)   h˜¨ ètype.func(*"".PrivateKey, *math/big.Int, *math/big.Int, *math/big.Int, *math/big.Int) (*math/big.Int, *math/big.Int)   €˜  &type.*"".PrivateKey   ˆ˜  $type.*math/big.Int   ˜  $type.*math/big.Int   ˜˜  $type.*math/big.Int    ˜  $type.*math/big.Int   ¨˜  $type.*math/big.Int   °˜  $type.*math/big.Int   ş´type..gc.func(*"".PrivateKey, *math/big.Int, *math/big.Int) (*math/big.Int, *math/big.Int)                    ş˜go.string."func(*ecdsa.PrivateKey, *big.Int, *big.Int) (*big.Int, *big.Int)" ˜  ’    @   func(*ecdsa.PrivateKey, *big.Int, *big.Int) (*big.Int, *big.Int)  ˜ ˜go.string."func(*ecdsa.PrivateKey, *big.Int, *big.Int) (*big.Int, *big.Int)"   ş¬type.func(*"".PrivateKey, *math/big.Int, *math/big.Int) (*math/big.Int, *math/big.Int) ¨  ¨   ;šN                                                                     ˜à  runtime.algarray    ˜  ´type..gc.func(*"".PrivateKey, *math/big.Int, *math/big.Int) (*math/big.Int, *math/big.Int)   (˜  ˜go.string."func(*ecdsa.PrivateKey, *big.Int, *big.Int) (*big.Int, *big.Int)"   8˜  ¾go.weak.type.*func(*"".PrivateKey, *math/big.Int, *math/big.Int) (*math/big.Int, *math/big.Int)   @˜  "runtime.zerovalue   P˜€ ¬type.func(*"".PrivateKey, *math/big.Int, *math/big.Int) (*math/big.Int, *math/big.Int)   h˜˜ ¬type.func(*"".PrivateKey, *math/big.Int, *math/big.Int) (*math/big.Int, *math/big.Int)   €˜  &type.*"".PrivateKey   ˆ˜  $type.*math/big.Int   ˜  $type.*math/big.Int   ˜˜  $type.*math/big.Int    ˜  $type.*math/big.Int   ş€type..gc.func(*"".PrivateKey, *math/big.Int, *math/big.Int) bool                    şxgo.string."func(*ecdsa.PrivateKey, *big.Int, *big.Int) bool" x  r    0   func(*ecdsa.PrivateKey, *big.Int, *big.Int) bool  ˜ xgo.string."func(*ecdsa.PrivateKey, *big.Int, *big.Int) bool"   şxtype.func(*"".PrivateKey, *math/big.Int, *math/big.Int) bool        ^IŒ?                                                                 ˜à  runtime.algarray    ˜  €type..gc.func(*"".PrivateKey, *math/big.Int, *math/big.Int) bool   (˜  xgo.string."func(*ecdsa.PrivateKey, *big.Int, *big.Int) bool"   8˜  Šgo.weak.type.*func(*"".PrivateKey, *math/big.Int, *math/big.Int) bool   @˜  "runtime.zerovalue   P˜€ xtype.func(*"".PrivateKey, *math/big.Int, *math/big.Int) bool   h˜˜ xtype.func(*"".PrivateKey, *math/big.Int, *math/big.Int) bool   €˜  &type.*"".PrivateKey   ˆ˜  $type.*math/big.Int   ˜  $type.*math/big.Int   ˜˜  type.bool   şttype..gc.func(*"".PrivateKey) *crypto/elliptic.CurveParams                    şrgo.string."func(*ecdsa.PrivateKey) *elliptic.CurveParams" p  l    -   func(*ecdsa.PrivateKey) *elliptic.CurveParams  ˜ rgo.string."func(*ecdsa.PrivateKey) *elliptic.CurveParams"   şltype.func(*"".PrivateKey) *crypto/elliptic.CurveParams      “â                                                         ˜à  runtime.algarray    ˜  ttype..gc.func(*"".PrivateKey) *crypto/elliptic.CurveParams   (˜  rgo.string."func(*ecdsa.PrivateKey) *elliptic.CurveParams"   8˜  ~go.weak.type.*func(*"".PrivateKey) *crypto/elliptic.CurveParams   @˜  "runtime.zerovalue   P˜€ ltype.func(*"".PrivateKey) *crypto/elliptic.CurveParams   h˜ˆ ltype.func(*"".PrivateKey) *crypto/elliptic.CurveParams   €˜  &type.*"".PrivateKey   ˆ˜  Btype.*crypto/elliptic.CurveParams   şŠtype..gc.func(*"".PrivateKey, []uint8) (*math/big.Int, *math/big.Int)                    ş‚go.string."func(*ecdsa.PrivateKey, []uint8) (*big.Int, *big.Int)" €  |    5   func(*ecdsa.PrivateKey, []uint8) (*big.Int, *big.Int)  ˜ ‚go.string."func(*ecdsa.PrivateKey, []uint8) (*big.Int, *big.Int)"   ş‚type.func(*"".PrivateKey, []uint8) (*math/big.Int, *math/big.Int)        ßÒ                                                                 ˜à  runtime.algarray    ˜  Štype..gc.func(*"".PrivateKey, []uint8) (*math/big.Int, *math/big.Int)   (˜  ‚go.string."func(*ecdsa.PrivateKey, []uint8) (*big.Int, *big.Int)"   8˜  ”go.weak.type.*func(*"".PrivateKey, []uint8) (*math/big.Int, *math/big.Int)   @˜  "runtime.zerovalue   P˜€ ‚type.func(*"".PrivateKey, []uint8) (*math/big.Int, *math/big.Int)   h˜ ‚type.func(*"".PrivateKey, []uint8) (*math/big.Int, *math/big.Int)   €˜  &type.*"".PrivateKey   ˆ˜  type.[]uint8   ˜  $type.*math/big.Int   ˜˜  $type.*math/big.Int   şÆtype..gc.func(*"".PrivateKey, *math/big.Int, *math/big.Int, []uint8) (*math/big.Int, *math/big.Int)                    şªgo.string."func(*ecdsa.PrivateKey, *big.Int, *big.Int, []uint8) (*big.Int, *big.Int)" ¨  ¤    I   func(*ecdsa.PrivateKey, *big.Int, *big.Int, []uint8) (*big.Int, *big.Int)  ˜ ªgo.string."func(*ecdsa.PrivateKey, *big.Int, *big.Int, []uint8) (*big.Int, *big.Int)"   ş¾type.func(*"".PrivateKey, *math/big.Int, *math/big.Int, []uint8) (*math/big.Int, *math/big.Int) °  °   ò	                                                                         ˜à  runtime.algarray    ˜  Ætype..gc.func(*"".PrivateKey, *math/big.Int, *math/big.Int, []uint8) (*math/big.Int, *math/big.Int)   (˜  ªgo.string."func(*ecdsa.PrivateKey, *big.Int, *big.Int, []uint8) (*big.Int, *big.Int)"   8˜  Ğgo.weak.type.*func(*"".PrivateKey, *math/big.Int, *math/big.Int, []uint8) (*math/big.Int, *math/big.Int)   @˜  "runtime.zerovalue   P˜€ ¾type.func(*"".PrivateKey, *math/big.Int, *math/big.Int, []uint8) (*math/big.Int, *math/big.Int)   h˜  ¾type.func(*"".PrivateKey, *math/big.Int, *math/big.Int, []uint8) (*math/big.Int, *math/big.Int)   €˜  &type.*"".PrivateKey   ˆ˜  $type.*math/big.Int   ˜  $type.*math/big.Int   ˜˜  type.[]uint8    ˜  $type.*math/big.Int   ¨˜  $type.*math/big.Int   ş&type.*"".PrivateKey  ˜  ˜   Ñƒ¿Ê                                                                                                                                                                                               L˜€  runtime.algarray    ˜  .type..gc.*"".PrivateKey   (˜  :go.string."*ecdsa.PrivateKey"   8˜  8go.weak.type.**"".PrivateKey   @˜  "runtime.zerovalue   H˜  $type."".PrivateKey   0˜P &type.*"".PrivateKey   `˜x &type.*"".PrivateKey   x˜  go.string."Add"   ˆ˜  Ètype.func(*math/big.Int, *math/big.Int, *math/big.Int, *math/big.Int) (*math/big.Int, *math/big.Int)   ˜  ètype.func(*"".PrivateKey, *math/big.Int, *math/big.Int, *math/big.Int, *math/big.Int) (*math/big.Int, *math/big.Int)   ˜˜  ("".(*PrivateKey).Add    ˜  ("".(*PrivateKey).Add   ¨˜  $go.string."Double"   ¸˜  Œtype.func(*math/big.Int, *math/big.Int) (*math/big.Int, *math/big.Int)   À˜  ¬type.func(*"".PrivateKey, *math/big.Int, *math/big.Int) (*math/big.Int, *math/big.Int)   È˜  ."".(*PrivateKey).Double   Ğ˜  ."".(*PrivateKey).Double   Ø˜  *go.string."IsOnCurve"   è˜  Xtype.func(*math/big.Int, *math/big.Int) bool   ğ˜  xtype.func(*"".PrivateKey, *math/big.Int, *math/big.Int) bool   ø˜  4"".(*PrivateKey).IsOnCurve   €˜  4"".(*PrivateKey).IsOnCurve   ˆ˜  $go.string."Params"   ˜˜  Ptype.func() *crypto/elliptic.CurveParams    ˜  ltype.func(*"".PrivateKey) *crypto/elliptic.CurveParams   ¨˜  ."".(*PrivateKey).Params   °˜  ."".(*PrivateKey).Params   ¸˜  4go.string."ScalarBaseMult"   È˜  btype.func([]uint8) (*math/big.Int, *math/big.Int)   Ğ˜  ‚type.func(*"".PrivateKey, []uint8) (*math/big.Int, *math/big.Int)   Ø˜  >"".(*PrivateKey).ScalarBaseMult   à˜  >"".(*PrivateKey).ScalarBaseMult   è˜  ,go.string."ScalarMult"   ø˜  type.func(*math/big.Int, *math/big.Int, []uint8) (*math/big.Int, *math/big.Int)   €˜  ¾type.func(*"".PrivateKey, *math/big.Int, *math/big.Int, []uint8) (*math/big.Int, *math/big.Int)   ˆ˜  6"".(*PrivateKey).ScalarMult   ˜  6"".(*PrivateKey).ScalarMult   ş8go.string."ecdsa.PrivateKey" 8  2       ecdsa.PrivateKey  ˜ 8go.string."ecdsa.PrivateKey"   şgo.string."D"          D  ˜ go.string."D"   şTgclocalsÂ·3280bececceccd33cb74587feedb1f9f           şTgclocalsÂ·d0639bedff7ffedcd56695753d30706e         «ª  şTgclocalsÂ·3280bececceccd33cb74587feedb1f9f           şTgclocalsÂ·dd6da6b6c0a8ea1724ec8c8531209fd3         «*   şTgclocalsÂ·3280bececceccd33cb74587feedb1f9f           şTgclocalsÂ·dafc2a4ed1eccf20e0ba3ca784d254a7         «*   şTgclocalsÂ·3280bececceccd33cb74587feedb1f9f           şTgclocalsÂ·743023cec9b4b515d11a8fbfd57d92fa         «   şTgclocalsÂ·3280bececceccd33cb74587feedb1f9f           şTgclocalsÂ·38322a79137eaa1c396e575f0b7238ea         «Z   şTgclocalsÂ·3280bececceccd33cb74587feedb1f9f           şTgclocalsÂ·edd717db8ce7af5b5c85b5a6296ab4e5         «ª  şîtype..gc.func("".PrivateKey, *math/big.Int, *math/big.Int, *math/big.Int, *math/big.Int) (*math/big.Int, *math/big.Int)                    ş¾go.string."func(ecdsa.PrivateKey, *big.Int, *big.Int, *big.Int, *big.Int) (*big.Int, *big.Int)" ¸  ¸    S   func(ecdsa.PrivateKey, *big.Int, *big.Int, *big.Int, *big.Int) (*big.Int, *big.Int)  ˜ ¾go.string."func(ecdsa.PrivateKey, *big.Int, *big.Int, *big.Int, *big.Int) (*big.Int, *big.Int)"   şætype.func("".PrivateKey, *math/big.Int, *math/big.Int, *math/big.Int, *math/big.Int) (*math/big.Int, *math/big.Int) ¸  ¸   ü¼IÍ                                                                             ˜à  runtime.algarray    ˜  îtype..gc.func("".PrivateKey, *math/big.Int, *math/big.Int, *math/big.Int, *math/big.Int) (*math/big.Int, *math/big.Int)   (˜  ¾go.string."func(ecdsa.PrivateKey, *big.Int, *big.Int, *big.Int, *big.Int) (*big.Int, *big.Int)"   8˜  øgo.weak.type.*func("".PrivateKey, *math/big.Int, *math/big.Int, *math/big.Int, *math/big.Int) (*math/big.Int, *math/big.Int)   @˜  "runtime.zerovalue   P˜€ ætype.func("".PrivateKey, *math/big.Int, *math/big.Int, *math/big.Int, *math/big.Int) (*math/big.Int, *math/big.Int)   h˜¨ ætype.func("".PrivateKey, *math/big.Int, *math/big.Int, *math/big.Int, *math/big.Int) (*math/big.Int, *math/big.Int)   €˜  $type."".PrivateKey   ˆ˜  $type.*math/big.Int   ˜  $type.*math/big.Int   ˜˜  $type.*math/big.Int    ˜  $type.*math/big.Int   ¨˜  $type.*math/big.Int   °˜  $type.*math/big.Int   ş²type..gc.func("".PrivateKey, *math/big.Int, *math/big.Int) (*math/big.Int, *math/big.Int)                    ş–go.string."func(ecdsa.PrivateKey, *big.Int, *big.Int) (*big.Int, *big.Int)"       ?   func(ecdsa.PrivateKey, *big.Int, *big.Int) (*big.Int, *big.Int)  ˜ –go.string."func(ecdsa.PrivateKey, *big.Int, *big.Int) (*big.Int, *big.Int)"   şªtype.func("".PrivateKey, *math/big.Int, *math/big.Int) (*math/big.Int, *math/big.Int) ¨  ¨   Œÿ‰x                                                                     ˜à  runtime.algarray    ˜  ²type..gc.func("".PrivateKey, *math/big.Int, *math/big.Int) (*math/big.Int, *math/big.Int)   (˜  –go.string."func(ecdsa.PrivateKey, *big.Int, *big.Int) (*big.Int, *big.Int)"   8˜  ¼go.weak.type.*func("".PrivateKey, *math/big.Int, *math/big.Int) (*math/big.Int, *math/big.Int)   @˜  "runtime.zerovalue   P˜€ ªtype.func("".PrivateKey, *math/big.Int, *math/big.Int) (*math/big.Int, *math/big.Int)   h˜˜ ªtype.func("".PrivateKey, *math/big.Int, *math/big.Int) (*math/big.Int, *math/big.Int)   €˜  $type."".PrivateKey   ˆ˜  $type.*math/big.Int   ˜  $type.*math/big.Int   ˜˜  $type.*math/big.Int    ˜  $type.*math/big.Int   ş~type..gc.func("".PrivateKey, *math/big.Int, *math/big.Int) bool                    şvgo.string."func(ecdsa.PrivateKey, *big.Int, *big.Int) bool" p  p    /   func(ecdsa.PrivateKey, *big.Int, *big.Int) bool  ˜ vgo.string."func(ecdsa.PrivateKey, *big.Int, *big.Int) bool"   şvtype.func("".PrivateKey, *math/big.Int, *math/big.Int) bool        "‚ù                                                                 ˜à  runtime.algarray    ˜  ~type..gc.func("".PrivateKey, *math/big.Int, *math/big.Int) bool   (˜  vgo.string."func(ecdsa.PrivateKey, *big.Int, *big.Int) bool"   8˜  ˆgo.weak.type.*func("".PrivateKey, *math/big.Int, *math/big.Int) bool   @˜  "runtime.zerovalue   P˜€ vtype.func("".PrivateKey, *math/big.Int, *math/big.Int) bool   h˜˜ vtype.func("".PrivateKey, *math/big.Int, *math/big.Int) bool   €˜  $type."".PrivateKey   ˆ˜  $type.*math/big.Int   ˜  $type.*math/big.Int   ˜˜  type.bool   şrtype..gc.func("".PrivateKey) *crypto/elliptic.CurveParams                    şpgo.string."func(ecdsa.PrivateKey) *elliptic.CurveParams" p  j    ,   func(ecdsa.PrivateKey) *elliptic.CurveParams  ˜ pgo.string."func(ecdsa.PrivateKey) *elliptic.CurveParams"   şjtype.func("".PrivateKey) *crypto/elliptic.CurveParams      Ó'î                                                         ˜à  runtime.algarray    ˜  rtype..gc.func("".PrivateKey) *crypto/elliptic.CurveParams   (˜  pgo.string."func(ecdsa.PrivateKey) *elliptic.CurveParams"   8˜  |go.weak.type.*func("".PrivateKey) *crypto/elliptic.CurveParams   @˜  "runtime.zerovalue   P˜€ jtype.func("".PrivateKey) *crypto/elliptic.CurveParams   h˜ˆ jtype.func("".PrivateKey) *crypto/elliptic.CurveParams   €˜  $type."".PrivateKey   ˆ˜  Btype.*crypto/elliptic.CurveParams   şˆtype..gc.func("".PrivateKey, []uint8) (*math/big.Int, *math/big.Int)                    ş€go.string."func(ecdsa.PrivateKey, []uint8) (*big.Int, *big.Int)" €  z    4   func(ecdsa.PrivateKey, []uint8) (*big.Int, *big.Int)  ˜ €go.string."func(ecdsa.PrivateKey, []uint8) (*big.Int, *big.Int)"   ş€type.func("".PrivateKey, []uint8) (*math/big.Int, *math/big.Int)        |Œ¤»                                                                 ˜à  runtime.algarray    ˜  ˆtype..gc.func("".PrivateKey, []uint8) (*math/big.Int, *math/big.Int)   (˜  €go.string."func(ecdsa.PrivateKey, []uint8) (*big.Int, *big.Int)"   8˜  ’go.weak.type.*func("".PrivateKey, []uint8) (*math/big.Int, *math/big.Int)   @˜  "runtime.zerovalue   P˜€ €type.func("".PrivateKey, []uint8) (*math/big.Int, *math/big.Int)   h˜ €type.func("".PrivateKey, []uint8) (*math/big.Int, *math/big.Int)   €˜  $type."".PrivateKey   ˆ˜  type.[]uint8   ˜  $type.*math/big.Int   ˜˜  $type.*math/big.Int   şÄtype..gc.func("".PrivateKey, *math/big.Int, *math/big.Int, []uint8) (*math/big.Int, *math/big.Int)                    ş¨go.string."func(ecdsa.PrivateKey, *big.Int, *big.Int, []uint8) (*big.Int, *big.Int)" ¨  ¢    H   func(ecdsa.PrivateKey, *big.Int, *big.Int, []uint8) (*big.Int, *big.Int)  ˜ ¨go.string."func(ecdsa.PrivateKey, *big.Int, *big.Int, []uint8) (*big.Int, *big.Int)"   ş¼type.func("".PrivateKey, *math/big.Int, *math/big.Int, []uint8) (*math/big.Int, *math/big.Int) °  °   ¥ÑX                                                                         ˜à  runtime.algarray    ˜  Ätype..gc.func("".PrivateKey, *math/big.Int, *math/big.Int, []uint8) (*math/big.Int, *math/big.Int)   (˜  ¨go.string."func(ecdsa.PrivateKey, *big.Int, *big.Int, []uint8) (*big.Int, *big.Int)"   8˜  Îgo.weak.type.*func("".PrivateKey, *math/big.Int, *math/big.Int, []uint8) (*math/big.Int, *math/big.Int)   @˜  "runtime.zerovalue   P˜€ ¼type.func("".PrivateKey, *math/big.Int, *math/big.Int, []uint8) (*math/big.Int, *math/big.Int)   h˜  ¼type.func("".PrivateKey, *math/big.Int, *math/big.Int, []uint8) (*math/big.Int, *math/big.Int)   €˜  $type."".PrivateKey   ˆ˜  $type.*math/big.Int   ˜  $type.*math/big.Int   ˜˜  type.[]uint8    ˜  $type.*math/big.Int   ¨˜  $type.*math/big.Int   ş,go.string."PrivateKey" (  &    
   PrivateKey  ˜ ,go.string."PrivateKey"   ş$type."".PrivateKey  ø  ø   A;!–                                                                                                                                                                                                                                            V˜  .type..alg."".PrivateKey    ˜  ,type..gc."".PrivateKey   (˜  8go.string."ecdsa.PrivateKey"   8˜  &type.*"".PrivateKey   @˜  "runtime.zerovalue   H˜` $type."".PrivateKey   p˜  "type."".PublicKey   ˆ˜  go.string."D"   ˜˜  $type.*math/big.Int   0˜° $type."".PrivateKey   °˜  ,go.string."PrivateKey"   ¸˜  "go.importpath."".   À˜Ø $type."".PrivateKey   Ø˜  go.string."Add"   è˜  Ètype.func(*math/big.Int, *math/big.Int, *math/big.Int, *math/big.Int) (*math/big.Int, *math/big.Int)   ğ˜  ætype.func("".PrivateKey, *math/big.Int, *math/big.Int, *math/big.Int, *math/big.Int) (*math/big.Int, *math/big.Int)   ø˜  ("".(*PrivateKey).Add   €˜  """.PrivateKey.Add   ˆ˜  $go.string."Double"   ˜˜  Œtype.func(*math/big.Int, *math/big.Int) (*math/big.Int, *math/big.Int)    ˜  ªtype.func("".PrivateKey, *math/big.Int, *math/big.Int) (*math/big.Int, *math/big.Int)   ¨˜  ."".(*PrivateKey).Double   °˜  ("".PrivateKey.Double   ¸˜  *go.string."IsOnCurve"   È˜  Xtype.func(*math/big.Int, *math/big.Int) bool   Ğ˜  vtype.func("".PrivateKey, *math/big.Int, *math/big.Int) bool   Ø˜  4"".(*PrivateKey).IsOnCurve   à˜  ."".PrivateKey.IsOnCurve   è˜  $go.string."Params"   ø˜  Ptype.func() *crypto/elliptic.CurveParams   €˜  jtype.func("".PrivateKey) *crypto/elliptic.CurveParams   ˆ˜  ."".(*PrivateKey).Params   ˜  ("".PrivateKey.Params   ˜˜  4go.string."ScalarBaseMult"   ¨˜  btype.func([]uint8) (*math/big.Int, *math/big.Int)   °˜  €type.func("".PrivateKey, []uint8) (*math/big.Int, *math/big.Int)   ¸˜  >"".(*PrivateKey).ScalarBaseMult   À˜  8"".PrivateKey.ScalarBaseMult   È˜  ,go.string."ScalarMult"   Ø˜  type.func(*math/big.Int, *math/big.Int, []uint8) (*math/big.Int, *math/big.Int)   à˜  ¼type.func("".PrivateKey, *math/big.Int, *math/big.Int, []uint8) (*math/big.Int, *math/big.Int)   è˜  6"".(*PrivateKey).ScalarMult   ğ˜  0"".PrivateKey.ScalarMult   ş&go.string."runtime"            runtime  ˜ &go.string."runtime"   ş,go.importpath.runtime.           ˜ &go.string."runtime"   şgo.string."io"          io  ˜ go.string."io"   ş"go.importpath.io.           ˜ go.string."io"   ş6go.string."crypto/elliptic" 0  0       crypto/elliptic  ˜ 6go.string."crypto/elliptic"   ş<go.importpath.crypto/elliptic.           ˜ 6go.string."crypto/elliptic"   ş(go.string."math/big" (  "       math/big  ˜ (go.string."math/big"   ş.go.importpath.math/big.           ˜ (go.string."math/big"   ş4type..hash."".PublicKeyÂ·f        ˜  .type..hash."".PublicKey   ş(runtime.interhashÂ·f        ˜  "runtime.interhash   ş$runtime.memhashÂ·f        ˜  runtime.memhash   ş0type..eq."".PublicKeyÂ·f        ˜  *type..eq."".PublicKey   ş$runtime.ifaceeqÂ·f        ˜  runtime.ifaceeq   ş,"".(*PublicKey).AddÂ·f        ˜  &"".(*PublicKey).Add   ş2"".(*PublicKey).DoubleÂ·f        ˜  ,"".(*PublicKey).Double   ş8"".(*PublicKey).IsOnCurveÂ·f        ˜  2"".(*PublicKey).IsOnCurve   ş2"".(*PublicKey).ParamsÂ·f        ˜  ,"".(*PublicKey).Params   şB"".(*PublicKey).ScalarBaseMultÂ·f        ˜  <"".(*PublicKey).ScalarBaseMult   ş:"".(*PublicKey).ScalarMultÂ·f        ˜  4"".(*PublicKey).ScalarMult   ş&"".PublicKey.AddÂ·f        ˜   "".PublicKey.Add   ş,"".PublicKey.DoubleÂ·f        ˜  &"".PublicKey.Double   ş2"".PublicKey.IsOnCurveÂ·f        ˜  ,"".PublicKey.IsOnCurve   ş,"".PublicKey.ParamsÂ·f        ˜  &"".PublicKey.Params   ş<"".PublicKey.ScalarBaseMultÂ·f        ˜  6"".PublicKey.ScalarBaseMult   ş4"".PublicKey.ScalarMultÂ·f        ˜  ."".PublicKey.ScalarMult   ş6type..hash."".PrivateKeyÂ·f        ˜  0type..hash."".PrivateKey   ş2type..eq."".PrivateKeyÂ·f        ˜  ,type..eq."".PrivateKey   ş."".(*PrivateKey).AddÂ·f        ˜  ("".(*PrivateKey).Add   ş4"".(*PrivateKey).DoubleÂ·f        ˜  ."".(*PrivateKey).Double   ş:"".(*PrivateKey).IsOnCurveÂ·f        ˜  4"".(*PrivateKey).IsOnCurve   ş4"".(*PrivateKey).ParamsÂ·f        ˜  ."".(*PrivateKey).Params   şD"".(*PrivateKey).ScalarBaseMultÂ·f        ˜  >"".(*PrivateKey).ScalarBaseMult   ş<"".(*PrivateKey).ScalarMultÂ·f        ˜  6"".(*PrivateKey).ScalarMult   ş("".PrivateKey.AddÂ·f        ˜  """.PrivateKey.Add   ş."".PrivateKey.DoubleÂ·f        ˜  ("".PrivateKey.Double   ş4"".PrivateKey.IsOnCurveÂ·f        ˜  ."".PrivateKey.IsOnCurve   ş."".PrivateKey.ParamsÂ·f        ˜  ("".PrivateKey.Params   ş>"".PrivateKey.ScalarBaseMultÂ·f        ˜  8"".PrivateKey.ScalarBaseMult   ş6"".PrivateKey.ScalarMultÂ·f        ˜  0"".PrivateKey.ScalarMult   ş"runtime.zerovalue      ÿÿgo13ld 